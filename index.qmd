---
title: "When not to avoid inbreeding: a gene's eye view perspective"
author: "Thomas Keaney, Arvid Agren and Hanna Kokko"
execute: 
  warning: false

format:
  html:
      theme: Minty # browse these here: https://quarto.org/docs/output-formats/html-themes.html
      max-width: 1800px # adjust if your plots don't fit or you want more or less whitespace
      toc: true # do you want a table of contents, by default it floats as you scroll
      toc-location: left # where should it be displayed
      toc-title: "Sections" 
      code-fold: true # fold code up for neater display
      smooth-scroll: true 
      embed-resources: true # output doc contains all info needed to display html    
---

# Load packages

```{r}
library(tidyverse) # for tidy style coding and plotting
library(pander) # for tables
library(kableExtra) # for scrolling tables
library(MetBrewer) # for colour palettes based upon artwork housed at the MET
library(MoMAColors) # for colour palettes based upon artwork housed at MoMA
library(wesanderson) # for colour palettes based on wes anderson movies
library(tidybayes) # for plotting distributions
library(stickylabeller) # labelling facets with strings in ggplot
library(patchwork) # for combining plots 
library(geomtextpath) # for curved plot annotations
library(ggtext) # for markdown syntax in plot labels
library(patchwork) # for patching plots together
library(ggnewscale) # to reset scales in plots, allowing multiple fill arguments in ggplot
library(data.table) # for efficient handling of large dataframes
library(dtplyr) # for tidyverse functions that can be used on data tables

```

# The model

## The seminal equation

To model the inclusive fitness gained from an inbred mating, three components that contribute to fitness are required:

1.  The number of offspring produced directly: $n$

2.  The reduction in fitness (number of offspring) due to inbreeding: $-\delta n$

3.  The indirect fitness gain (number of offspring) due to inbreeding: $rn$, where $r$ is the relatedness coefficient

Put together, the inclusive fitness from a single inbred mating is:

$$(1 + r)(1 - \delta)n$$

while fitness from a single outbred mating is simply $n$.

When $(1 + r)(1 - \delta)n \gt n$ selection should favour a preference for inbreeding.

Solving the inequality for $\delta$:

$$\delta \lt \frac{r}{1 + r}$$ which for varying values of $r$ looks like this:

```{r, echo=TRUE}

inbreeding_maximum_function <- function(r){
  r / (1 + r)}


parameters <- expand_grid(r = seq(from = 0, to = 1, by = 0.05),
                          delta = seq(from = 0, to = 1, by = 0.05))

r <- parameters %>% distinct(r)

inbreeding_equilibria <- 
  map_dfr(r, inbreeding_maximum_function) %>% 
  rename(inbreeding_depression = r) %>% 
  bind_cols(r)

inbreeding_equilibria %>% 
  ggplot(aes(x = r, y = inbreeding_depression)) +
  geom_line(linewidth = 0.8) + 
  coord_cartesian(ylim = c(0, 1)) +
  labs(x = '_r_, the relatedness coefficient',
       y = ~delta~'(inbreeding depression)') +
  scale_x_continuous(expand = c(0, 0.009)) + 
  scale_y_continuous(expand = c(0, 0)) +
  theme_bw() +
  theme(text = element_text(size = 14),
        axis.title.x = element_markdown())

# (prop fitness lost)\n that can be tolerated"

```

The parameter space above the curve shows where inbreeding avoidance should evolve, while the parameter space below the curve shows where inbreeding preference should evolve.

## Accounting for sex differences in genetic architecture

As stated above, inclusive fitness in the absence of inbreeding depression is $(1 + r)n$. Here $r$ represents the correlation between genotypes carried by interacting females and males, under the implicit assumption that loci appear equally in both sexes. However, given that there is sexual dimorphism in genetic architecture for many taxa, $r$ does not sufficiently represent the correlation between genotypes for all loci.

To delineate differences in the effect of $r$ for different regions of the genome, we multiply $r$ with a new variable $a$, the probability that a locus present in one sex is also present in the gametes produced by the other. Unlike $r$ which is relative to the population mean relatedness, $a$ is expressed as an absolute value ranging from 0 to 1.

The indirect component of fitness accrued by from an inbred mating becomes

$$ran$$

and inclusive fitness from an inbreeding event becomes

$$(1 + ra)(1 - \delta )n$$

Taking an allele found at a diploid autosomal locus as an example, all of the gametes produced by a relative possess this locus, where they could potentially carry alleles identical by descent. In this case $a = 1$ and the indirect component of inclusive fitness is dictated solely by $r$. The results for this autosomal scenario are presented in Parker (1979), Kokko and Ots (2006) and others who have explored this topic. In contrast, an inbreeding preference allele present at a locus on a Y or W chromosome has no opportunity to propagate any alleles identical by descent through inbreeding, as these chromosomes are not carried by the gametes of the opposite sex mating partner. In this case $a = 0$. However, as inbreeding depression is a result of homozygosity for deleterious recessive alleles throughout the genome, the costs of inbreeding depression are born by all alleles carried by the individual. Conflict over the expression of inbreeding preference between alleles present on autosomes and those present on hemizygous sex chromosomes is immediately clear.

X- or Z-linked loci present an interesting intermediate case, with sex-specific values for $a$. When the inbreeding locus is carried by the sex with homozygous sex chromosomes, $a$ is half that of autosomal loci, whereas it does not depart from the autosomal case when the locus is found within the hemizygous sex. Using loci on the X as an example, those present in a XX female are only found in \~50% of a interacting males gametes, as the remaining 50% carry Y chromosomes (assuming an even primary sex ratio). When an X-linked locus is found in a male, an interacting female's gametes all carry X chromosomes and $a = 1$.

The X/Z situation is made additionally complex because there is an element of frequency dependence to the kin selected benefits. When an inbreeding allele on an autosome is rare, then the chance of a relative carrying two copies is low, whereas when the allele is common, this chance is much higher. Rarity therefore leads to similar fitness outcomes for autosomal and X/Z linked alleles (when present in the hemizygous sex), while commonality of the allele likely roughly equates to the conflicting situation outlined in the above paragraph. However, frequency dependence might not as relevant as I initially expected, because the inbreeding allele becomes very common quickly within families, even whilst rare across the population (first proposed in Fisher, 1930).

**Table 1.** Values of the parameter $a$ for different regions of the genome. $a$ is the one-way probability that a locus carried by one individual is found within the gametes of an opposite sex individual. Note that cytoplasmic chromosomes are assumed to have exclusive maternal inheritance.

```{r}
x <- 
  c(1, # autosomes, X chromosome males or Z chromosome females, haplodiploid both sexes when producing females 
    0, # Y or W chromosome
    0.5 # X chromosome females or Z chromosome males
  )

tibble(`Prob. that opposite sex gametes carry focal locus` = c(1, 0.5, 0),
       `Relevant cases` = c("Autosomes in either sex, X chromosomes in males, Z chromosomes in females, chromosomes in haplodiploids of either sex when reproducing sexually, cytoplasmic chromosomes in males",
                            "X chromosomes in females, Z chromosomes in males",
                            "Y chromosomes in males, W chromosomes in females, cytoplasmic chromosomes in females")) %>% 
  pander(split.cell = 20, split.table = Inf)
```

Once again we can find the condition where breeding with a relative returns greater fitness than an inbreeding avoidance strategy, this time accounting for genetic architecture

$$\delta \lt \frac{ra}{1 + ra}$$

Ignoring frequency dependence for now, we can plot the new slopes produced by varying $r$ and $a$:

```{r}

inbreeding_maximum_function_2 <- function(r, a){
  (r*a / (r*a + 1))}


parameters_2 <- expand_grid(r = seq(from = 0, to = 1, by = 0.01),
                          a = c(0, 0.5, 1))

inbreeding_equilibria_2 <- 
  map2_dfr(parameters_2 %>% select(r), 
           parameters_2 %>% select(a), 
           inbreeding_maximum_function_2) %>% 
  rename(inbreeding_depression = r) %>% 
  bind_cols(parameters_2)

inbreeding_equilibria_2 %>% 
  mutate(a = case_when(a == 0 ~ "a = 0",
                       a == 0.5 ~ "a = 0.5",
                       a == 1 ~ "a = 1")) %>% 
  mutate(a = as.factor(a)) %>% 
  ggplot(aes(x = r, y = inbreeding_depression, linetype = a, label = a)) +
  geom_textline(linewidth = 0.8, size = 5) + 
 # scale_colour_manual(values = c("0" = met.brewer("Kandinsky", 4)[1], "0.5" =  met.brewer("Kandinsky", 4)[2], "1" = met.brewer("Kandinsky", 4)[3])) +
  coord_cartesian(ylim = c(0, 1)) +
  labs(x = '_r_, the relatedness coefficient',
       y = ~delta~'(inbreeding depression)',
       linetype = expression(~italic(a)~', the intersex correlation between loci')) +
  scale_x_continuous(expand = c(0.009, 0)) + 
  scale_y_continuous(expand = c(0.025, 0)) +
  theme_bw() +
  theme(text = element_text(size = 18),
        legend.position = "none",
        axis.title.x = element_markdown())
```

$~$

## Differences between the sexes beyond genetic architecture

Parker's seminal equations:

In his 1979 book chapter, Parker considered the inclusive fitness results of breeding with a relative and identified that females and males should have different tolerances for inbreeding depression. The key departure from the unlimited polygyny case presented in the above equations is that a cost to future reproductive success is included for males, i.e. due to finite sperm production, parental care, or harmful mating behaviour such as sexual cannibalism.

For males, Parker found that selection would favour inbreeding with a sister (full-sib) who could otherwise outcross when:

$$n(1 - \delta) + rn(1- \delta) - cn \gt rn$$

the first term is the direct number of alleles propagated, the second term is the indirect number of alleles propagated (note that this is weighted by relatedness), the third term is the direct number of alleles that were not directly propagated by the male through outcrossing, and the final opposing term is the number of alleles that would've been transmitted had his sister outcrossed (and he forgone mating).

$c$ is the cost of the present mating, relative to what is lost for a female. This can be considered a ratio of parental investment. When $c = 1$ parental investment in the current bout of reproduction is even between the sexes. Alternatively, if males only contribute cheaply produced sperm to an incestuous mating, the cost of mating is likely very small relative to females i.e. $c ~ 0$.

We add the $a$ variable to the equation and letting $n = 1$, simplify to

$$(1-\delta) + ra(1-\delta) - c \gt ra$$

We can again find the condition where breeding with a relative returns greater fitness than an inbreeding avoidance strategy:

$$\delta_{male} = \frac{1 - c}{1 + ra}$$

Parker then modelled the condition for monandrous females to prefer incestuous matings when also presented with an outcrossing opportunity.

$$n(1 - \delta) + rn(1-\delta) - crn \gt n$$

which we can write as

$$(1-\delta) + ra(1-\delta) - rac \gt 1$$

the inbreeding depression threshold is

$$\delta_{female} = \frac{ra - rac}{1 + ra}$$

Note that when $c = 0$, this is equivalent to the $\delta$ threshold found in the single mating case.

Plot the relationship between $r$ and $\delta$ for several values of $c$ and $a$

```{r}

Parker_cost_data <- 
  expand_grid(r = seq(from = 0, to = 1, by = 0.01),
              a = c(0, 0.5, 1),
              c = c(0, 0.5, 0.9),
              Sex = c("Female", "Male")) %>% 
  mutate(inbreeding_depression = case_when(Sex == "Female" ~ (r*a - r*a*c) / (r*a + 1),
                                           Sex == "Male" ~ (1 - c) / (r*a + 1)))

  Parker_cost_data %>% 
  mutate(a = as.factor(a)) %>% 
  ggplot(aes(x = r, y = inbreeding_depression, linetype = a, colour = Sex)) +
  geom_line(linewidth = 0.9) + 
  scale_colour_manual(values = c("Female" = met.brewer("Peru1", 6)[2], "Male" =  met.brewer("Peru1", 6)[3])) +
  coord_cartesian(ylim = c(0, 1)) +
  labs(y = expression(delta), 
       x = expression(italic("r")),
       linetype = expression(italic("a"))) +
  scale_x_continuous(expand = c(0.009, 0)) + 
  scale_y_continuous(expand = c(0.01, 0)) +
  facet_wrap(~c, nrow = 3, labeller = label_glue('Male mating investment (c): {c}')) +
  theme_bw() +
  theme(text = element_text(size = 14),
        strip.background = element_rect(fill = "Aliceblue", linewidth = .5))

```

## Plotting sexual and intragenomic conflicts

```{r}
resolution <- 200

parameters <- 
  expand_grid(
    r = seq(0, 1, length = resolution),
    a = c(0, 0.5, 1),
    c = c(0, 0.25, 0.5, 0.75, 1),
    D = seq(0, 1, length = resolution)) # D represents inbreeding depression)

results <-
  parameters %>% 
  mutate(female_inbreeding_fitness = (1-D) + (r*a*(1-D)) - (r*a*c),
         male_inbreeding_fitness = (1-D) + r*a*(1-D) - c,
         female_outbreeding_fitness = 1,
         male_outbreeding_fitness = r*a,
         female_fitness_contrast = female_inbreeding_fitness - female_outbreeding_fitness, # this is close to a selection differential
         male_fitness_contrast = male_inbreeding_fitness - male_outbreeding_fitness)

```


### When is inbreeding favoured in each sex?

In the figure below, the dashed lines indicate the level of inbreeding depression that can be tolerated for a given value of $r$. The plot is split into panels by $c$, the cost of mating for males relative to females and $a$, the probability that a locus present in one sex is also present in the gametes produced by the other.

```{r}
pal1 <- met.brewer("OKeeffe1", n=100, direction = -1)
pal2 <- met.brewer("Hiroshige", n=50, direction = -1)
#pal2 <- moma.colors("Avedon", n = 50, direction = 1)

oranges <- c("#ffe6b7", "#ffd06f", "#f7aa58", "#ef8a47", "#e76254") 

blues <- c("#aadce0", "#72bcd5", "#528fad", "#376795", "#1e466e")

# Lowest colour for all gradients
gradient_base <- oranges[1]

gradient_max <- oranges[5]

# Create a list of gradients for each colour 2 to 10 over five steps from 
# gradient_base grey (low) to colour (high)
my_gradient <- colorRampPalette(c(gradient_base, gradient_max))(50)
  
Female_plot <-
  results %>%
  filter(c != 0.25, c != 0.75, c != 1) %>% 
  ggplot(aes(x = r, y = D)) +
  geom_blank() +
  geom_raster(aes(fill = female_fitness_contrast)) + 
  stat_contour(aes(z = female_fitness_contrast*100), colour = "black", binwidth = 25,
               breaks = c(-125, -100, -75, -50, -25, 25, 50, 75, 100, 125)) +
  stat_contour(aes(z = female_fitness_contrast*100), colour = "black", breaks = 0,
               linetype = 2) +
  #geom_line(data = female_inbreeding_equilibria, aes(x = r, y = D),
   #         linetype = 3, alpha = 0.5) +
  scale_fill_gradientn(colours = pal1, breaks = c(-1.5, -0.75, 0, 0.75, 1.5), limits = c(-2, 2)) +
  facet_wrap(c ~ a, 
             scales = "free", nrow = 2, strip.position = c("top"),
             labeller = label_glue('c = {`c`}, a = {`a`}')) +
  labs(x = '_r_, the relatedness coefficient',
       y = ~delta~'(inbreeding depression)',
       fill = "Inbreeding fitness",
       title = "A. Alleles present in females") +
  scale_x_continuous(expand = c(0, 0)) + 
  scale_y_continuous(expand = c(0, 0)) + # labels = c(0, 25, 50, 75, 90)) +
  theme(panel.border = element_rect(fill = NA, colour = "black", linewidth = .8),
        strip.background = element_rect(colour = "black", fill = "Aliceblue", linewidth = .8),
        axis.title.x = element_markdown(),
        plot.title = element_text(hjust = 0.5))


Male_plot <-
  results %>%
  filter(c != 0.25, c != 0.75, c != 1) %>% 
  ggplot(aes(x = r, y = D)) +
  geom_blank() +
  geom_raster(aes(fill = male_fitness_contrast)) + 
  stat_contour(aes(z = male_fitness_contrast*100), colour = "black", binwidth = 25,
              breaks = c(-125, -100, -75, -50, -25, 25, 50, 75, 100, 125)) +
  stat_contour(aes(z = male_fitness_contrast*100), colour = "black", breaks = 0,
               linetype = 2) +
  #geom_line(data = female_inbreeding_equilibria, aes(x = r, y = D),
   #         linetype = 3, alpha = 0.5) +
  scale_fill_gradientn(colours = pal1, breaks = c(-1.5, -0.75, 0, 0.75, 1.5), limits = c(-2, 2)) +
  facet_wrap(c ~ a, 
             scales = "free", nrow = 2, strip.position = c("top"),
             labeller = label_glue('c = {`c`}, a = {`a`}')) +
  labs(x = '_r_, the relatedness coefficient',
       y = ~delta~'(inbreeding depression)',
       fill = "Inbreeding fitness",
       title = "B. Alleles present in males") +
  scale_x_continuous(expand = c(0, 0)) + 
  scale_y_continuous(expand = c(0, 0)) + # labels = c(0, 25, 50, 75, 90)) +
  theme(panel.border = element_rect(fill = NA, colour = "black", linewidth = .8),
        strip.background = element_rect(colour = "black", fill = "Aliceblue", linewidth = .8),
        axis.title.x = element_markdown(),
        plot.title = element_text(hjust = 0.5))

Female_plot

Male_plot

```

### When is there evolutionary conflict over inbreeding?

To quantify conflict in its various forms we use a version of the _I_ index presented in [Innocenti and Morrow (2010)](https://academic.oup.com/evolut/article/64/9/2775/6854370).

Panels in columns A and B show the parameter space where conflict is expected between alleles on different chromosomes - so called inter-chromosomal conflict.

```{r}

Intragenomic_conflict_females <-
  results %>%
  select(1:4, female_fitness_contrast) %>%
  pivot_wider(names_from = a, values_from = female_fitness_contrast) %>% 
  #mutate(`Autosome - X` = `1` - `0.5`,
   #      `Autosome - Z` = 0,
    #     `Autosome - W & Z - W` = `1` - `0`) %>% 
  mutate(`Autosome vs X` = `1` * `0.5` / sqrt(((`1`)^2 + (`0.5`)^2)/2),
         `Autosome vs Z` = `1` * `1` / sqrt(((`1`)^2 + (`1`)^2)/2),
         `Autosome & Z vs W` = `1` * `0` / sqrt(((`1`)^2 + (`0`)^2)/2)) %>% 
  pivot_longer(cols = 7:9, names_to = "contrast", values_to = "Evolutionary_conflict") %>% 
  mutate(relationship = case_when(
    contrast == "Autosome vs X" & `1` > 0 & `0.5` > 0 ~
      "Inbreeding favoured in both contexts",
    contrast == "Autosome vs X" & `1` < 0 & `0.5` < 0 ~
       "Inbreeding deleterious in both contexts",
    
    contrast == "Autosome vs Z" & `1` > 0 ~
      "Inbreeding favoured in both contexts",
    contrast == "Autosome vs Z" & `1` < 0 ~
       "Inbreeding deleterious in both contexts",
    
    contrast == "Autosome & Z vs W" & `1` > 0 & `0` > 0 ~
      "Inbreeding favoured in both contexts",
    contrast == "Autosome & Z vs W" & `1` < 0 & `0` < 0 ~
       "Inbreeding deleterious in both contexts",
    `0` == 0 & `0.5` == 0 & `1` == 0 ~ "Inbreeding deleterious in both contexts",  
    .default = "Intragenomic conflict")) %>% 
  mutate(contrast = fct_relevel(contrast, "Autosome vs X", "Autosome vs Z",
                                "Autosome & Z vs W")) %>% 
  filter(c == 0)  # remove if we want more c values

Intragenomic_conflict_males <-
  results %>%
  select(1:4, male_fitness_contrast) %>%
  pivot_wider(names_from = a, values_from = male_fitness_contrast) %>% 
  #mutate(`Autosome - X` = 0,
   #      `Autosome - Z` = `1` - `0.5`,
    #     `Autosome - Y & X - Y` = `1` - `0`) %>%
  mutate(`X vs Autosome` = `1` * `1` / sqrt(((`1`)^2 + (`1`)^2)/2),
         `Z vs Autosome` = `1` * `0.5` / sqrt(((`1`)^2 + (`0.5`)^2)/2),
         `Y vs Autosome & X` = `1` * `0` / sqrt(((`1`)^2 + (`0`)^2)/2)) %>% 
  pivot_longer(cols = 7:9, names_to = "contrast", values_to = "Evolutionary_conflict") %>% 
  mutate(relationship = case_when(
    contrast == "X vs Autosome" & `1` > 0 ~
      "Inbreeding favoured in both contexts",
    contrast == "X vs Autosome" & `1` < 0 ~
      "Inbreeding deleterious in both contexts",
    
    contrast == "Z vs Autosome" & `1` > 0 & `0.5` > 0 ~
      "Inbreeding favoured in both contexts",
    contrast == "Z vs Autosome" & `1` < 0 & `0.5` < 0 ~
      "Inbreeding deleterious in both contexts",
    
    contrast == "Y vs Autosome & X" & `1` > 0 & `0` > 0 ~
      "Inbreeding favoured in both contexts",
    contrast == "Y vs Autosome & X" & `1` < 0 & `0` < 0 ~
      "Inbreeding deleterious in both contexts",
    `0` == 0 & `0.5` == 0 & `1` == 0 ~ "Inbreeding deleterious in both contexts",  
    .default = "Intragenomic conflict")) %>% 
  mutate(contrast = fct_relevel(contrast, "X vs Autosome", "Z vs Autosome",
                                "Y vs Autosome & X")) %>% 
  filter(c == 0) # remove if we want more c values
    

make_genomic_conflict_plot <- 
  function(data, enter_title, colour_pal){
    data %>% 
      ggplot(aes(x = r, y = D)) +
      geom_blank() +
      geom_tile(data = data %>% filter(relationship == "Intragenomic conflict"),
                aes(fill = Evolutionary_conflict*-1)) + 
      #geom_tile(data = data,
      #         aes(fill = Evolutionary_conflict)) + 
      scale_fill_gradientn(colours = colour_pal, limits = c(0, 0.6), #na.value = "white",
                           breaks = c(0, 0.6),
                           labels = c("Weak conflict", "Strong conflict")) +
      labs(fill = "Evolutionary conflict") +
      new_scale_fill() +
      geom_tile(data = data %>% filter(relationship != "Intragenomic conflict"),
                aes(fill = relationship), alpha = 0.75) +
      scale_fill_manual(values = c("#fbe6c5", "#d2fbd4"), 
                        labels = c("Inbreeding deleterious\nin both contexts", 
                               "Inbreeding favoured\nin both contexts")) +
      stat_contour(aes(z = Evolutionary_conflict*-1), colour = "black", binwidth = 25,
                   breaks = c(0, 0.2, 0.4, 0.6)) +
      facet_wrap(~contrast, nrow = 3,
                 scales = "free", strip.position = c("top"),
                 labeller = label_glue('{`contrast`}')) +
      labs(x = '_r_ (relatedness coefficient)',
           y = ~delta~'(inbreeding depression)',
           fill = "Evolutionary concordance",
           title = enter_title) +
      scale_x_continuous(expand = c(0, 0)) + 
      scale_y_continuous(expand = c(0, 0)) + # labels = c(0, 25, 50, 75, 90)) +
      theme(panel.border = element_rect(fill = NA, colour = "black", size = .8),
            panel.grid.minor = element_blank(),
            strip.background = element_rect(colour = "black", fill = "Aliceblue", linewidth = .8),
            axis.title.x = element_markdown(),
            plot.title = element_text(hjust = 0.5, size = 10))
  }

icf <- make_genomic_conflict_plot(Intragenomic_conflict_females, "A. Inter-chromosomal conflict in females", oranges)
icm <- make_genomic_conflict_plot(Intragenomic_conflict_males, "B. Inter-chromosomal conflict in males", oranges)

```

Panels in column C show where loci are expected to be under intra-chromosomal sexual conflict over inbreeding preference. In regions of sexual conflict, inbreeding preference is always favoured in males, but has negative fitness consequences if expressed by females (assuming that males invest less into mating than females). Note that intra-chromosomal conflict encompasses both the intra- and inter-locus forms of sexual conflict.   

```{r}

autosomal_data <-
  results %>%
  filter(a == 1, c != 1, c != 0.25) %>% 
  #mutate(Evolutionary_conflict = male_fitness_contrast - female_fitness_contrast) %>%
  mutate(Evolutionary_conflict = female_fitness_contrast * male_fitness_contrast / 
           sqrt(((female_fitness_contrast)^2 + (male_fitness_contrast)^2)/2)) %>% 
  mutate(relationship = 
           case_when(female_fitness_contrast < 0 & male_fitness_contrast > 0 
                     ~ "Sexual conflict",
                     female_fitness_contrast < 0 & male_fitness_contrast < 0 
                     ~ "Inbreeding deleterious in both contexts",
                     female_fitness_contrast > 0 & male_fitness_contrast > 0 
                     ~ "Inbreeding favoured in both contexts"),
         Location = "Autosome") 
  


X_data <- 
  results %>% 
  filter(a == 0.5, c != 1, c != 0.25) %>%  
  select(1:4, contains("female")) %>% 
  rename(a_female = a) %>% # this step makes the join work as intended
  left_join(
    results %>% 
      filter(a == 1, c != 1, c != 0.25) %>% 
      select(1:4, starts_with("male")) %>% 
      rename(a_male = a) # this step makes the join work as intended
  ) %>%
  #mutate(Evolutionary_conflict = male_fitness_contrast - female_fitness_contrast) %>% 
  mutate(Evolutionary_conflict = female_fitness_contrast * male_fitness_contrast / 
           sqrt(((female_fitness_contrast)^2 + (male_fitness_contrast)^2)/2)) %>% 
  mutate(relationship = 
           case_when(female_fitness_contrast < 0 & male_fitness_contrast > 0 
                     ~ "Sexual conflict",
                     female_fitness_contrast < 0 & male_fitness_contrast < 0 
                     ~ "Inbreeding deleterious in both contexts",
                     female_fitness_contrast > 0 & male_fitness_contrast > 0 
                     ~ "Inbreeding favoured in both contexts"),
         Location = "X")

Z_data <-
  results %>% 
  filter(a == 1, c != 1, c != 0.25) %>%  
  select(1:4, contains("female")) %>% 
  rename(a_female = a) %>% 
  left_join(
    results %>% 
      filter(a == 0.5, c != 1, c != 0.25) %>% 
      select(1:4, starts_with("male")) %>% 
      rename(a_male = a)
  ) %>% 
  #mutate(Evolutionary_conflict = male_fitness_contrast - female_fitness_contrast) %>%
  mutate(Evolutionary_conflict = female_fitness_contrast * male_fitness_contrast / 
           sqrt(((female_fitness_contrast)^2 + (male_fitness_contrast)^2)/2)) %>% 
  mutate(relationship = 
           case_when(female_fitness_contrast < 0 & male_fitness_contrast > 0 
                     ~ "Sexual conflict",
                     female_fitness_contrast < 0 & male_fitness_contrast < 0 
                     ~ "Inbreeding deleterious in both contexts",
                     female_fitness_contrast > 0 & male_fitness_contrast > 0 
                     ~ "Inbreeding favoured in both contexts"),
         Location = "Z")

plotting_data <- bind_rows(autosomal_data, X_data, Z_data) %>% filter(c == 0)

Sexual_conflict_plot <-
  plotting_data %>%
  ggplot(aes(x = r, y = D)) +
  geom_blank() +
  geom_tile(data = plotting_data %>% filter(relationship == "Sexual conflict"),
            aes(fill = Evolutionary_conflict*-1)) + 
  #scale_fill_gradientn(colours = pal2, limits = c(-1.2, 1.1), #na.value = "white",
   #                    labels = c("Strong conflict, female (+)", -0.5, 
    #                              "No conflict", 0.5, "Strong conflict, male (+)")) +
  scale_fill_gradientn(colours = oranges, limits = c(0, 0.6), #na.value = "white",
                       breaks = c(0, 0.6),
                       labels = c("Weak conflict", "Strong conflict")) +
  labs(fill = "Evolutionary conflict") +
  new_scale_fill() +
  geom_tile(data = plotting_data %>% filter(relationship != "Sexual conflict"),
            aes(fill = relationship), alpha = 0.75) +
  scale_fill_manual(values = c("#fbe6c5", "#d2fbd4"), 
                    labels = c("Inbreeding deleterious\nin both contexts", 
                               "Inbreeding favoured\nin both contexts")) +
  stat_contour(aes(z = Evolutionary_conflict*-1), colour = "black", binwidth = 25,
                   breaks = c(0, 0.2, 0.4, 0.6)) +
  facet_wrap(~Location, nrow = 3,
             scales = "free", strip.position = c("top"),
             labeller = label_glue('{`Location`}')) +
  labs(x = '_r_ (relatedness coefficient)',
       y = ~delta~'(inbreeding depression)',
       fill = "Evolutionary concordance",
       title = "C. Intra-chromosomal sexual conflict") +
  scale_x_continuous(expand = c(0, 0)) + 
  scale_y_continuous(expand = c(0, 0)) + # labels = c(0, 25, 50, 75, 90)) +
  theme(panel.border = element_rect(fill = NA, colour = "black", size = .8),
        strip.background = element_rect(colour = "black", fill = "Aliceblue", linewidth = .8),
        axis.title.x = element_markdown(),
        plot.title = element_text(hjust = 0.5, size = 10))

```

## Make Figure 1

```{r, fig.height=7, fig.width=8.6}
icf + icm + Sexual_conflict_plot + plot_layout(guides = "collect")
```

# The simulation

**A work in progress...**

Parker's $c$ value offers a simple, intuitive way to model the cost of mating for males relative to females. However, other methods better capture the dynamics of real populations, where both sexes also run the risk of going unmated. To incorporate both costs of mating and matelessness, we simulate the invasion of an allele that encodes a preference for inbreeding, for loci on various chromosomes and with different sex-specific expression profiles.

## Build a mating table

Something to think about is how we set genetics to affect the expression of inbreeding tolerance/preference. Things that matter include:

1. do we consider inbreeding expression as the additive result of multiple loci on different chromosomes, or do we consider each case separately. **Probably not this**

2. is inbreeding expression binary, a threshold trait or a quantitative, normally distributed trait. The latter would allow us to model evolution towards some maximum. The former cases are simpler to code (particularly the first case) but still allow us to answer a very similar question. **I have this as an additive case - being heterozygous leads to expression of inbreeding preference half of the time.**

```{r}

make_mating_table <- function(gene_location){
  
  make_offspring <- function(X, Y, type, zygote_freq, gene_location){
    tibble(Female_genotype = X,
           Male_genotype = Y,
           type,
           zygote_freq,
           locus_type = gene_location)
  }
  
  
  # Set up the  possible mating duo types
  
  #mating_types <- 
   # bind_rows(
      # autosomal
    #  expand_grid(
     #   mother = c("A_IA_I.Female",
      #             "A_IA_O.Female",
       #            "A_OA_O.Female"),
        #father = c("A_IA_I.Male",
         #          "A_IA_O.Male",
          #         "A_OA_O.Male")) %>% 
        #mutate(locus_type = "autosomal"),
      # XY (both can encode inbreeding but they're expressed independently)
      #expand_grid(
       # mother = c("X_IX_I.Female",
        #           "X_IX_O.Female",
         #          "X_OX_O.Female"),
        #father = c("X_IY_I.Male",
         #          "X_IY_O.Male",
          #         "X_OY_I.Male",
           #        "X_OY_O.Male")) %>% 
        #mutate(locus_type = "XY"),
      # ZW (as per the XY case)
     # expand_grid(
      #  mother = c("Z_IW_I.Female",
       #            "Z_IW_O.Female",
        #           "Z_OW_I.Female",
         #          "Z_OW_O.Female"),
        #father = c("Z_IZ_I.Male",
         #          "Z_IZ_O.Male",
          #         "Z_OZ_O.Male")) %>% 
        #mutate(locus_type = "ZW"),
      # cytoplasmic
      #expand_grid(
       # mother = c("C_I.Female",
        #           "C_O.Female"),
        #father = c("C_I.Male",
         #          "C_O.Male")) %>% 
        #mutate(locus_type = "cytoplasmic")
    #) %>% 
    #mutate(locus_type = gene_location)
  
  # Specify the possible offspring genotypes for all the potential crosses; we use these for the type argument in the make_offspring function
  
  # autosomal
  
  # II x II
  
  a_genotype_1 <- c("A_IA_I.Female", "A_IA_I.Male")
  
  # II x IO
  
  a_genotype_2 <- c("A_IA_I.Female", "A_IA_I.Male", 
                    "A_IA_O.Female", "A_IA_O.Male")
  
  # II x OO
  
  a_genotype_3 <- c("A_IA_O.Female", "A_IA_O.Male")
  
  # IO x IO
  
  a_genotype_4 <- c("A_IA_I.Female", "A_IA_I.Male", 
                    "A_IA_O.Female", "A_IA_O.Male", 
                    "A_OA_O.Female", "A_OA_O.Male")
  
  # IO x OO
  
  a_genotype_5 <- c("A_IA_O.Female", "A_IA_O.Male",
                    "A_OA_O.Female", "A_OA_O.Male")
  
  # OO x OO
  
  a_genotype_6 <- c("A_OA_O.Female", "A_OA_O.Male")
  
  # XY
  
  
  # II x IY_I
  
  xy_genotype_1 <- c("X_IX_I.Female", "X_IY_I.Male")
  
  # II x IY_O
  
  xy_genotype_2 <- c("X_IX_I.Female", "X_IY_O.Male")
  
  # II x OY_I
  
  xy_genotype_3 <- c("X_IX_O.Female", "X_IY_I.Male")
  
  # II x OY_O
  
  xy_genotype_4 <- c("X_IX_O.Female", "X_IY_O.Male")
  
  # IO x IY_I
  
  xy_genotype_5 <- c("X_IX_I.Female", "X_IY_I.Male",
                     "X_IX_O.Female", "X_OY_I.Male")
  
  # IO x IY_O
  
  xy_genotype_6 <- c("X_IX_I.Female", "X_IY_O.Male", 
                     "X_IX_O.Female", "X_OY_O.Male")
  
  # IO x OY_I
  
  xy_genotype_7 <- c("X_IX_O.Female", "X_IY_I.Male",
                     "X_OX_O.Female", "X_OY_I.Male")
  
  # IO x OY_O
  
  xy_genotype_8 <- c("X_IX_O.Female", "X_IY_O.Male",
                     "X_OX_O.Female", "X_OY_O.Male")
  
  # OO x IY_I
  
  xy_genotype_9 <- c("X_IX_O.Female", "X_OY_I.Male")
  
  # OO x IY_O
  
  xy_genotype_10 <- c("X_IX_O.Female", "X_OY_O.Male")
  
  # OO x OY_I
  
  xy_genotype_11 <- c("X_OX_O.Female", "X_OY_I.Male")
  
  # OO x OY_O
  
  xy_genotype_12 <- c("X_OX_O.Female", "X_OY_O.Male")
  
  # ZW
  
  # IW_I x II
  
  zw_genotype_1 <- c("Z_IZ_I.Male", "Z_IW_I.Female")
  
  # IW_I x IO
  
  zw_genotype_2 <- c("Z_IZ_I.Male", "Z_IZ_O.Male", 
                     "Z_IW_I.Female", "Z_OW_I.Male")
  
  # IW_I x OO
  
  zw_genotype_3 <- c("Z_IZ_O.Male", "Z_OW_I.Female")
  
  # IW_O x II
  
  zw_genotype_4 <- c("Z_IZ_I.Male", "Z_IW_O.Female")
  
  # IW_O x IO
  
  zw_genotype_5 <- c("Z_IZ_I.Male", "Z_IZ_O.Male",
                     "Z_IW_O.Female", "Z_OW_O.Female")
  
  # IW_O x OO
  
  zw_genotype_6 <- c("Z_IZ_O.Male", "Z_OW_O.Female")
  
  # OW_I X II
  
  zw_genotype_7 <- c("Z_IZ_O.Male", "Z_IW_I.Female")
  
  # OW_I x IO
  
  zw_genotype_8 <- c("Z_IZ_O.Male", "Z_OZ_O.Male",
                     "Z_IW_I.Female", "Z_OW_I.Female")
  
  # OW_I x OO
  
  zw_genotype_9 <- c("Z_OZ_O.Male", "Z_OW_I.Female")
  
  # OW_O X II
  
  zw_genotype_10 <- c("Z_IZ_O.Male", "Z_IW_O.Female")
  
  # OW_O x IO
  
  zw_genotype_11 <- c("Z_IZ_O.Male", "Z_OZ_O.Male",
                      "Z_IW_O.Female", "Z_OW_O.Female")
  
  # OW_O x OO
  
  zw_genotype_12 <- c("Z_OZ_O.Male", "Z_OW_O.Female")
  
  # cytoplasmic
  
  # I x I
  # I x O
  
  c_genotype_1 <- c("C_I.Female", "C_I.Male")
  
  # O x O
  # O x I
  
  c_genotype_2 <- c("C_O.Female", "C_O.Male")
  
  
  
  # Now calculate the zygote frequencies for each cross
  
  # autosomal
  
  # even frequency of two offspring genotypes
  
  freq_2 <- rep(0.5, 2)
  
  # even frequency between four offspring types
  
  freq_4 <- rep(0.25, 4)
  
  # when there are 6 offspring genotypes
  
  freq_6 <- c(0.125, 0.125,
              0.25, 0.25,
              0.125, 0.125)
  
  bind_rows(
    list(
      make_offspring("A_IA_I", "A_IA_I", a_genotype_1, freq_2, "autosomal"),
      make_offspring("A_IA_I", "A_IA_O", a_genotype_2, freq_4, "autosomal"),
      make_offspring("A_IA_I", "A_OA_O", a_genotype_3, freq_2, "autosomal"),
      make_offspring("A_IA_O", "A_IA_I", a_genotype_2, freq_4, "autosomal"),
      make_offspring("A_IA_O", "A_IA_O", a_genotype_4, freq_6, "autosomal"),
      make_offspring("A_IA_O", "A_OA_O", a_genotype_5, freq_4, "autosomal"),
      make_offspring("A_OA_O", "A_IA_I", a_genotype_3, freq_2, "autosomal"),
      make_offspring("A_OA_O", "A_IA_O", a_genotype_5, freq_4, "autosomal"),
      make_offspring("A_OA_O", "A_OA_O", a_genotype_6, freq_2, "autosomal"),
      
      make_offspring("X_IX_I", "X_IY_I", xy_genotype_1, freq_2, "XY"),
      make_offspring("X_IX_I", "X_IY_O", xy_genotype_2, freq_2, "XY"),
      make_offspring("X_IX_I", "X_OY_I", xy_genotype_3, freq_2, "XY"),
      make_offspring("X_IX_I", "X_OY_O", xy_genotype_4, freq_2, "XY"),
      make_offspring("X_IX_O", "X_IY_I", xy_genotype_5, freq_4, "XY"),
      make_offspring("X_IX_O", "X_IY_O", xy_genotype_6, freq_4, "XY"),
      make_offspring("X_IX_O", "X_OY_I", xy_genotype_7, freq_4, "XY"),
      make_offspring("X_IX_O", "X_OY_O", xy_genotype_8, freq_4, "XY"),
      make_offspring("X_OX_O", "X_IY_I", xy_genotype_9, freq_2, "XY"),
      make_offspring("X_OX_O", "X_IY_O", xy_genotype_10, freq_2, "XY"),
      make_offspring("X_OX_O", "X_OY_I", xy_genotype_11, freq_2, "XY"),
      make_offspring("X_OX_O", "X_OY_O", xy_genotype_12, freq_2, "XY"),
      
      make_offspring("Z_IW_I", "Z_IZ_I", zw_genotype_1, freq_2, "ZW"),
      make_offspring("Z_IW_I", "Z_IZ_O", zw_genotype_2, freq_4, "ZW"),
      make_offspring("Z_IW_I", "Z_OZ_O", zw_genotype_3, freq_2, "ZW"),
      make_offspring("Z_IW_O", "Z_IZ_I", zw_genotype_4, freq_2, "ZW"),
      make_offspring("Z_IW_O", "Z_IZ_O", zw_genotype_5, freq_4, "ZW"),
      make_offspring("Z_IW_O", "Z_OZ_O", zw_genotype_6, freq_2, "ZW"),
      make_offspring("Z_OW_I", "Z_IZ_I", zw_genotype_7, freq_2, "ZW"),
      make_offspring("Z_OW_I", "Z_IZ_O", zw_genotype_8, freq_4, "ZW"),
      make_offspring("Z_OW_I", "Z_OZ_O", zw_genotype_9, freq_2, "ZW"),
      make_offspring("Z_OW_O", "Z_IZ_I", zw_genotype_10, freq_2, "ZW"),
      make_offspring("Z_OW_O", "Z_IZ_O", zw_genotype_11, freq_4, "ZW"),
      make_offspring("Z_OW_O", "Z_OZ_O", zw_genotype_12, freq_2, "ZW"),
      
      make_offspring("C_I", "C_I", c_genotype_1, freq_2, "cytoplasmic"),
      make_offspring("C_I", "C_O", c_genotype_1, freq_2, "cytoplasmic"),
      make_offspring("C_O", "C_I", c_genotype_2, freq_2, "cytoplasmic"),
      make_offspring("C_O", "C_O", c_genotype_2, freq_2, "cytoplasmic")
    )) %>% 
    filter(locus_type == gene_location)
}

```

Load the inheritance schemes, to speed up the simulation

```{r}
# load the possible inheritance schemes

offspring_genotypes_autosome <- 
  make_mating_table(gene_location = "autosomal") %>% 
  select(1:4) %>% 
  rename(zygote_type = type) %>% 
  separate_wider_delim(zygote_type, names = c("Genotype", "Sex"), delim = ".") %>% 
  mutate(Sex = if_else(Sex == "Female", 1, 0)) %>% 
  as.data.table()

offspring_genotypes_X <- 
  make_mating_table(gene_location = "XY") %>% 
  select(1:4) %>% 
  rename(zygote_type = type) %>% 
  separate_wider_delim(zygote_type, names = c("Genotype", "Sex"), delim = ".") %>% 
  mutate(Sex = if_else(Sex == "Female", 1, 0)) %>% 
  filter(!str_detect(Male_genotype, "Y_I")) %>% 
  as.data.table()

offspring_genotypes_Y <- 
  make_mating_table(gene_location = "XY") %>% 
  select(1:4) %>% 
  rename(zygote_type = type) %>% 
  separate_wider_delim(zygote_type, names = c("Genotype", "Sex"), delim = ".") %>% 
  mutate(Sex = if_else(Sex == "Female", 1, 0)) %>% 
  filter(!str_detect(Female_genotype, "X_I"),
         !str_detect(Male_genotype, "X_I")) %>% 
  as.data.table()

offspring_genotypes_Z <- 
  make_mating_table(gene_location = "ZW") %>% 
  select(1:4) %>% 
  rename(zygote_type = type) %>% 
  separate_wider_delim(zygote_type, names = c("Genotype", "Sex"), delim = ".") %>% 
  mutate(Sex = if_else(Sex == "Female", 1, 0)) %>% 
  filter(!str_detect(Female_genotype, "W_I")) %>% 
  as.data.table()

offspring_genotypes_W <- 
  make_mating_table(gene_location = "ZW") %>% 
  select(1:4) %>% 
  rename(zygote_type = type) %>% 
  separate_wider_delim(zygote_type, names = c("Genotype", "Sex"), delim = ".") %>% 
  mutate(Sex = if_else(Sex == "Female", 1, 0)) %>% 
  filter(!str_detect(Female_genotype, "Z_I"),
         !str_detect(Male_genotype, "Z_I")) %>% 
  as.data.table()

offspring_genotypes_cytoplasmic <- 
  make_mating_table(gene_location = "cytoplasmic") %>% 
  select(1:4) %>% 
  rename(zygote_type = type) %>% 
  separate_wider_delim(zygote_type, names = c("Genotype", "Sex"), delim = ".") %>% 
  mutate(Sex = if_else(Sex == "Female", 1, 0)) %>% 
  as.data.table()
```

An example of the mating table, for an autosomal locus

```{r}
make_mating_table(gene_location = "autosomal") %>% 
  rename(zygote_type = type) %>% 
  kable() %>% 
  kable_styling() %>% 
  scroll_box(height = "500px")
```

## Build a function to create the starting population

Following Ekrem and Kokko (2023), we find the reproductive lifespans of `N` diploid individuals in a sexually reproducing population to initialise the simulation. Mortality events are drawn from an exponential distribution with rate $\lambda = 1/\mu$. The probability of mortality is therefore constant across the reproductive lifespan for each sex. 

Lets have a look at the mean lifespan drawn from the exponential distribution parameterised with different mortality rates.

```{r}
#exponential_draws <-
  tibble(`Mean lifespan` = seq(from = 0.01, to = 2.01, by = 0.1)) %>% 
  mutate(`Corresponding mortality rate` = 1/`Mean lifespan`) %>% 
  arrange(-`Mean lifespan`) %>% 
  pander()

```

We use these values to inform our parameterisation of inbreeding depression ($\delta$). Individuals that don't inbreed produce offspring with a mean lifespan of 2 time units. We then increase the rate of mortality to increase the severity of inbreeding depression, lowering the mean lifespan of inbred offspring.

```{r}

# build the function to find individual lifespans
 
build_starting_pop <-
  function(seed, pop_size, mean_lifespan){
    #set.seed(seed)
    
    population <-
      data.table(Lifespan = rexp(n = pop_size, rate = 1/mean_lifespan),
                 Sex = rbinom(n = pop_size, 1, prob = 0.5),
                 birth_time = 0,
                 matings = 0)
    
    population[, `:=` (Genotype = ifelse(Sex > 0, Female_starting_genotype, Male_starting_genotype),
                      Mortality_time = Lifespan,
                      breeding = Sex,
                      Individual_ID = .I,
                      Family_ID = rep(1:(.N/10), each = 10, length.out = .N))]
  }

```

## Create a function to add the inbreeding allele to the population

Each individual possesses an inbreeding locus with two possible alleles. The `A_O` allele encodes inbreeding avoidance, whereas the `A_I` allele encodes inbreeding tolerance. We assume that dominance is additive, such that any individuals carrying one copy of the `A_I` allele express inbreeding tolerance in 50% of cases, whereas homozygous individuals always express a tolerance of inbreeding (**we can review this assumption once I have it coded and working**). 

```{r}

mutate_sample <- 
  function(df, number_mutants) {
     df[sample(which(str_detect(Genotype, pattern = chromosome)), size = number_mutants, replace = F),
             Genotype := str_replace(Genotype, pattern = paste0(chromosome, "_O"), replacement = paste0(chromosome, "_I"))]
  }

```

## Create a function to produce a candidate list of mating events

With individual reproductive lifespans known, we can then calculate time stamps for every possible female-male encounter for this set of individuals. For each focal male, the time to finding each specific female is drawn from a negative exponential distribution, with rate $\frac{v}{N_F}$. $v$ represents the search efficiency of males in the population, where higher values indicate more efficient mate finding. The end result is a complete schedule of female-male interactions across the generation's reproductive lifespan.

```{r}
 
candidate_timestamp_finder <- 
  function(Female_ID, Male_ID, v, Female_pop_size){
    CJ(Female_ID, Male_ID)[, Mate_encounter_time_stamp := rexp(n = .N, rate = (v/(Female_pop_size)))
    ][, `:=`( mated = 0,
             inbred_mating = 0,
             female_matings = 0,
             male_matings = 0,
             reproduced = 0,
             counted = 0)]
  }

```

## Create a function to calculate the population-wide frequency of the inbreeding allele

```{r}

# function for autosomal alleles
calc_prop_autosomal_inbreeding_allele <- function(pop, heterozygous_genotype, homozygous_genotype, sex_homozygous){
  (0.5 * length(pop$Genotype[str_detect(pop$Genotype, heterozygous_genotype)])/ nrow(pop)) + 
    (length(pop$Genotype[str_detect(pop$Genotype, homozygous_genotype)])/ nrow(pop)) 
}

# function for hemizygous alleles: W, Y or cytoplasmic

calc_prop_hemizygous_inbreeding_allele <- function(pop, heterozygous_genotype, homozygous_genotype, sex_homozygous){
  (length(pop$Genotype[str_detect(pop$Genotype, homozygous_genotype)])/ 
     length(pop$Genotype[str_detect(pop$Genotype, chromosome)]))
}

# function for alleles diploid in one sex and haploid in the other: X and Z

calc_prop_XZ_inbreeding_allele <- function(pop, heterozygous_genotype, homozygous_genotype, sex_homozygous){
  if(sex_homozygous == 1){
    (0.5 * length(pop$Genotype[str_detect(pop$Genotype, heterozygous_genotype)] & pop$Sex == sex_homozygous)/ nrow(pop)) + 
      (length(pop$Genotype[str_detect(pop$Genotype, homozygous_genotype)] & pop$Sex == sex_homozygous)/ nrow(pop)) +
      (length(pop$Genotype[str_detect(pop$Genotype, "I")] & pop$Sex != sex_homozygous)/ nrow(pop))}
  else{
    (0.5 * length(pop$Genotype[str_detect(pop$Genotype, heterozygous_genotype)] & pop$Sex == sex_homozygous)/ nrow(pop)) + 
      (length(pop$Genotype[str_detect(pop$Genotype, homozygous_genotype)] & pop$Sex == sex_homozygous)/ nrow(pop)) +
      (length(pop$Genotype[str_detect(pop$Genotype, "I")] & pop$Sex != sex_homozygous)/ nrow(pop))}
}

```

Death of a breeding female triggers replacement by a new breeding individual, assuming that there is >=1 non-breeding female in the population. If there are multiple non-breeding females, the new breeder is selected with probability 1 / number of non-breeding females.

## Define the parameter space

```{r}

resolution <- 25

parameters <-
  expand_grid(
    C = c(2, 10),
    v = c(1, 10, 100),
    prob_sibling_mating = seq(0, 1, length = resolution),
    D = seq(0, -1.99, length = resolution)) %>% 
  mutate(Starting_pop_size = 200,
         baseline_mean_lifespan = 2,
         N = 10,
         number_mutants = 1,
         time_end = 100,
         parameter_space_ID = row_number())

```

## Speed testing

The fuction below can be used to test computation speed

```{r, eval=FALSE}
bench::mark({

  }, iterations = 100)
```

## Build the main simulation function

The simulation progresses through time. Fates of individuals are pre-calculated and occur in continuous time. We monitor the population regularly (time increments of 0.1) and update the population by:

1. Checking whose still alive

2. Finding new breeding females if there's space and the females to fill it. All individuals in the population can mate but only those holding breeding sites can produce offspring.

3. Checking if mating occurs (including inbreeding). 

4. Adding new individuals to the population when there are new mated breeders. 

5. Generating fates for all new individuals and updating the fates of existing individuals.

The simulation ends when the inbreeding allele goes extinct, fixes or the time limit elapses.

We run one simulation per row in the parameter space table.

```{r}

continuous_time_simulation <- function(row,
                                       parameters,
                                       expression, # 0 = in males, 1 = in females
                                       chromosome, # where does the inbreeding mutation occur
                                       inheritance_scheme, # mutation occurs on A, X, Y, Z or C
                                       allele_freq_finder, # depends on inheritance scheme
                                       heterozygous_genotype, # if hemizygous NA, else specify
                                       homozygous_genotype, # homozygote for inbreeding allele)
                                       sex_homozygous){ # if hemizygous 0 or 1, else NA 
  
  print(paste("Doing row", row)) # this tells you which row in the parameter space is being modelled
  
  Starting_pop_size <- parameters$Starting_pop_size[row]
  C <- parameters$C[row]
  v <- parameters$v[row]
  baseline_mean_lifespan <- parameters$baseline_mean_lifespan[row]
  N <- parameters$N[row]
  D <- parameters$D[row]
  number_mutants <- parameters$number_mutants[row]
  prob_sibling_mating <- parameters$prob_sibling_mating[row]
  time_end <- parameters$time_end[row]
  
  # define the starting genotypes for each sex so the population table can be built
  
  Female_starting_genotype <- inheritance_scheme[.N]$Female_genotype
  
  Male_starting_genotype <- inheritance_scheme[.N]$Male_genotype
  
  # make sure random number generation is not replicated across simulation runs
  
  #set.seed(runif(1, 0, 1))
  
  # Initialize the timer t to 0
  t <- 0
  
  # Set the number of breeding sites
  
  breeding_sites <- 0.5*Starting_pop_size
  
  # Initialize the Individual_ID  and Family_ID counters
  
  Individual_ID_counter <- Starting_pop_size
  
  Family_ID_counter <- Starting_pop_size/10 # the sim starts with 200 individuals from 200 different families...
  
  keep_going <- TRUE # if the inbreeding allele fixes or goes extinct, this will change to false and the while loop will quit early
  
  # the simulation tracks the population via two dataframes. The first holds info about the individuals in the population, while the second (the candidate list) holds info on encounters between males and females in the population
  
  # create the starting population - note that females are sex = 1 and males are sex = 0
  
  population <- 
    build_starting_pop(pop_size = Starting_pop_size, 
                       mean_lifespan = baseline_mean_lifespan)
  
  # seed population with the inbreeding allele using our custom mutate_sample() function
  
  #population <-
  mutate_sample(population,
                number_mutants = number_mutants)
  
  # create sex specific data tables that can be matched to the mating timestamps
  
  female_population <-
    population[Sex > 0, 
               .(Female_ID = Individual_ID, 
                 Female_genotype = Genotype, 
                 Female_mortality_time = Mortality_time,
                 breeding,
                 Female_family_ID = Family_ID)] 
  
  
  male_population <-
    population[Sex < 1, 
               .(Male_ID = Individual_ID, 
                 Male_genotype = Genotype, 
                 Male_mortality_time = Mortality_time,
                 Male_family_ID = Family_ID)] 
  
  # Create the initial candidate list of mating interactions
  
  initial_females <- female_population[, Female_ID]
  
  initial_males <- male_population[, Male_ID]
  
  candidate_list <- 
    candidate_timestamp_finder(Female_ID = initial_females,
                               Male_ID = initial_males,
                               v = v,
                               Female_pop_size = length(initial_females)
    )[female_population, on = 'Female_ID' # join the important genetic and life history info
    ][male_population, on = "Male_ID"]
  
  # With the initial population and mating schedule ready to go, start the timer and let the simulation run. In short, time progresses and events with predetermined time stamps occur. These events trigger new actions which can lead to the production of new breeding individuals, which have their own timeline of predetermined events and interactions.
  
  while (t <= time_end & keep_going) {
    
    # step 1. check whose still alive
    
    population <-
      population[Mortality_time > t]
    
    # step 2. find new breeders if there's space and females to fill it
    
    # Get the current size of the breeding female population 
    
    current_breeders <- sum(population$breeding > 0) #length(which(population$breeding > 0))
    
    # If there are available breeding sites, and females to fill them, recruit new breeders
    
    if(current_breeders < breeding_sites && sum(population$Sex > 0 & population$breeding < 1) > 0){
      
      # choose whether site or female availability limits recruitment
      
      size_input <- min(breeding_sites - current_breeders, 
                        sum(population$Sex > 0 & population$breeding < 1))
      
      # assign the new breeders
      
      population <- population[sample(which(breeding < 1 & Sex > 0),
                                      size = size_input, 
                                      replace = FALSE), # note that all females have equal prob of becoming a breeder atm
                               breeding := 1]
      
      # slot the newly updated population info into the candidate list
      
      candidate_list <- candidate_list[population[Sex > 0, .(Female_ID = Individual_ID, breeding)], 
                                       on = .(Female_ID),
                                       breeding := i.breeding]
    }
    
    # step 3. mating
    
    # trim the candidate list by removing 1) removing all encounters for individuals that have died and 2) all encounters from the past, except those that led to mating but haven't yet led to reproduction (we need these later). t - 0.1 is used because time elapsed increases by 0.1 units every iteration.  
    
    candidate_list <- candidate_list[Female_mortality_time > t &
                                       Male_mortality_time > t & 
                                       (Mate_encounter_time_stamp > t - 0.1 | mated > 0 & reproduced < 1)]
    
    # now use the list to check whether there are any female-male encounters at this moment that result in mating
    # to do this, first create a table holding all encounters that occur at the current time
    
    encounters <- candidate_list[Mate_encounter_time_stamp <= t]
    
    # if an encounter occurs involving an individual carrying the A_I allele, provide an opportunity for inbreeding. Heterozygotes inbreed with 0.5 probability i.e. additive genetic expression. The hurdle requirement for an inbreeding opportunity is that an individual must stay alive long enough to meet any member of the opposite sex. We then code the simulation such that this opposite sex individual is swapped out for a full-sibling that can be mated with. This simulates a common situation in nature, where due to population viscosity, relatives live in close geographic proximity and are thus more likely to be encountered. 
    
    inbreeders <- data.table(Female_ID=numeric(), Male_ID=numeric()) # keeps the model running if no inbreeding occurs at t
    
    # find males that will inbreed when they are the sex that expresses inbreeding tolerance
    
    if(expression < 1 & sum(str_detect(encounters$Male_genotype, "I") > 0)){
      
      inbreeding_male_IDs <- 
        unique(copy(encounters)
               [str_detect(Male_genotype, "A_IA_O"), inbreeding := rbinom(.N, 1, 0.5) # heterozygotes
               ][str_detect(Male_genotype, "A_IA_I"), inbreeding := 1 # homozygotes
               ][inbreeding > 0, .(Male_ID) # select those that inbreed
               ])[, mate_with_full_sib := rbinom(.N, 1, prob_sibling_mating)] # manipulate r with prob_sibling_mating
      
      # find new mates for males, first those chosen to mate with a full sib, then those that mate at random in the pop
      
      inbreeders <-
        unique(
          rbindlist(list(
            candidate_list[inbreeding_male_IDs, on = "Male_ID"
            ][mate_with_full_sib > 0 & 
                Female_family_ID == Male_family_ID & # this line produces full-sib mating, if a receptive sib exists
                female_matings < 1 & 
                male_matings < C,
              .SD[sample(.N, 1, replace = F)], by = "Male_ID"], # choose a sister to mate with 
            
            candidate_list[inbreeding_male_IDs, on = "Male_ID"
            ][mate_with_full_sib < 1 &
                female_matings < 1 & 
                male_matings < C, 
              .SD[sample(.N, 1, replace = F)], by = "Male_ID"] # choose random female from population to mate with
          ))[, `:=`(mated = 1, Mate_encounter_time_stamp = t, inbred_mating = 1) # change mating status and move encounter time forward
          ][, mate_with_full_sib := NULL],
          by = "Female_ID" # make sure no female is chosen twice
        )[, .(Female_ID, Male_ID, mated, Mate_encounter_time_stamp, inbred_mating)] 
      
      # update the candidate list by moving the chosen mating forward to the present time.
      
      candidate_list[inbreeders, `:=` (mated = i.mated, 
                                       Mate_encounter_time_stamp = i.Mate_encounter_time_stamp,
                                       inbred_mating = i.inbred_mating),
                     on = .(Female_ID, Male_ID)]
    }
    
    # find females that will inbreed when they are the sex that expresses inbreeding tolerance
    
    if(expression > 0 & sum(str_detect(encounters$Female_genotype, "I") > 0)){
      
      inbreeding_female_IDs <- 
        unique(copy(encounters)
               [str_detect(Female_genotype, "A_IA_O"), inbreeding := rbinom(.N, 1, 0.5) # heterozygotes
               ][str_detect(Female_genotype, "A_IA_I"), inbreeding := 1 # homozygotes
               ][inbreeding > 0, .(Female_ID)
               ])[, mate_with_full_sib := rbinom(.N, 1, prob_sibling_mating)] # manipulate r with prob_sibling_mating
      
      # find new mates for females, first those chosen to mate with a full sib, then those that mate at random in the pop
      
      inbreeders <-
        unique(
          rbindlist(list(
            candidate_list[inbreeding_female_IDs, on = "Female_ID"
            ][mate_with_full_sib > 0 & 
                Female_family_ID == Male_family_ID & # this line produces full-sib mating
                female_matings < 1 & 
                male_matings < C,
              .SD[sample(.N, 1)], by = "Female_ID"], # choose brother to mate with
            
            candidate_list[inbreeding_female_IDs, on = "Female_ID"
            ][mate_with_full_sib < 1 &
                female_matings < 1 & 
                male_matings < C, 
              .SD[sample(.N, 1)], by = "Female_ID"] # choose random male from population to mate with
          ))[, `:=`(mated = 1, Mate_encounter_time_stamp = t, inbred_mating = 1) # change mating status and move encounter forward
          ][, mate_with_full_sib := NULL],
          by = "Male_ID" # make sure no male is chosen twice
        )[, .(Female_ID, Male_ID, mated, Mate_encounter_time_stamp, inbred_mating)] 
      
      # update the candidate list by moving the chosen mating forward to the present time. 
      
      candidate_list[inbreeders, `:=` (mated = i.mated, 
                                       Mate_encounter_time_stamp = i.Mate_encounter_time_stamp,
                                       inbred_mating = i.inbred_mating),
                     on = .(Female_ID, Male_ID)]
    }
    
    # conduct 'normal' matings
    
    receptive_encounters <-
      encounters[female_matings < 1 & male_matings < C
      ][, f_number := .N, keyby = Female_ID
      ][, m_number := .N,  by = Male_ID
      ][!inbreeders, on = .(Female_ID) # remove females involved in inbreeding at this time
      ][!inbreeders, on = .(Male_ID)] # remove males involved in inbreeding at this time
    
    # if individuals encounter multiple individuals at once, make sure they just choose one to mate with. If two individuals choose the same individual of the opposite sex, one randomly succeeds and the other(s) miss out
    
    if(max(receptive_encounters$f_number) > 1 | max(receptive_encounters$m_number) > 1){
      
      likely_matings <- receptive_encounters[, 
                                             .I[Mate_encounter_time_stamp == min(Mate_encounter_time_stamp)], 
                                             by = Female_ID]$V1
      
      chosen_matings <- unique(receptive_encounters[likely_matings, 
                                                    .(Male_ID, Female_ID)], 
                               by = "Male_ID")[, mated := 1]
      
      # update the candidate list
      
      candidate_list <- candidate_list[chosen_matings, 
                                       on = .(Male_ID = Male_ID, Female_ID = Female_ID), 
                                       mated := i.mated]
      
    } else{
      candidate_list <-
        candidate_list[!inbreeders, on = .(Female_ID) # remove females involved in inbreeding at this time
        ][!inbreeders, on = .(Male_ID)  # remove males involved in inbreeding at this time
        ][Mate_encounter_time_stamp <= t &
            female_matings < 1 &
            male_matings < C, mated := 1]
    }
    
    # update the mating tally in the population tibble
    # the counted variable indicates that the successful mating has already been included in the female and males mating tally
    # new matings combines the inbred matings and the 'normal matings' that occur at time t
    
    new_matings <- 
      candidate_list[mated > 0 & counted < 1,][, `:=`(matings = 1)][, .(Female_ID, Male_ID, matings)]
    
    if(nrow(new_matings) > 0){
      # melt reshapes the table from wide to long, like pivot_longer in the tidyverse
      population <- population[melt(new_matings,
                                    measure.vars = c("Female_ID", "Male_ID"),
                                    value.name = "Individual_ID")[,.(Individual_ID, matings)], 
                               `:=`(matings = matings + i.matings), on = "Individual_ID"]
      
      
      # update the mating tally in the candidate list and check specific matings off as counted
      
      new_mated_females <- 
        new_matings[, .(Female_ID, female_matings = matings)]
      
      new_mated_males <- 
        new_matings[, .(Male_ID, male_matings = matings)]
      
      candidate_list <- 
        candidate_list[new_mated_females, 
                       female_matings := female_matings + i.female_matings, 
                       on = "Female_ID"
        ][new_mated_males, male_matings := male_matings + i.male_matings, 
          on = "Male_ID"
        ][new_matings, counted := 1, on = c("Female_ID", "Male_ID")] # this ticks the mating off as counted
    }
    
    # step 4: reproduction
    
    # check how many females can now produce offspring, either because they're previously mated and have secured a breeding site or because they already held a breeding site and have now mated
    
    new_mated_breeders <- sum(candidate_list$mated > 0 & 
                                candidate_list$breeding > 0 & 
                                candidate_list$reproduced < 1)
    
    if(new_mated_breeders > 0) {
      # add offspring to the population. Each mated female that holds a breeding site produces N offspring
      offspring <- 
        candidate_list[mated > 0 & breeding > 0 & reproduced < 1, 
        ][inheritance_scheme, 
          on = .(Female_genotype = Female_genotype,
                 Male_genotype = Male_genotype), 
          nomatch = NULL, allow.cartesian  = TRUE
        ][, .SD[sample(.N, 
                       size = N, 
                       prob = zygote_freq, 
                       replace = T)],
          by = .(Female_ID, 
                 Male_ID)
        ][, Family_ID := .GRP + Family_ID_counter,
          by = .(Female_ID, 
                 Male_ID)
        ][, .(Genotype, 
              Sex, 
              inbred_mating,
              Family_ID)
        ][, `:=`(birth_time = t,
                 Lifespan = ifelse(inbred_mating > 0, rexp(.N, rate = 1/(baseline_mean_lifespan + D)),
                                   rexp(.N, rate = 1/baseline_mean_lifespan)),
                 breeding = 0,
                 matings = 0)
        ][, Mortality_time := Lifespan + birth_time
        ][, Individual_ID := .I + Individual_ID_counter
        ][, c(-3)] # dangerous coding but this drops the inbred mating column that we don't need in the population table
      
      # bind the offspring table to the existing population table  
      
      population <- rbindlist(list(population, offspring), use.names = TRUE)
      
      # update the reproduced column in the candidate list 
      
      candidate_list <- candidate_list[mated > 0 & breeding > 0 & reproduced < 1, reproduced := 1]
      
      # update the candidate list with new members of the population
      
      # setup dummy dts so we can bind everything at once, which saves time
      
      new_female_mating_encounter_times <- data.table(Female_ID=numeric(), Male_ID=numeric()) 
      new_male_mating_encounter_times <- data.table(Female_ID=numeric(), Male_ID=numeric()) 
      
      # first get all relevant data from the population table
      new_females <- population[Sex > 0 & birth_time == t, 
                                .(Female_ID = Individual_ID,
                                  Female_mortality_time = Mortality_time,
                                  Female_genotype = Genotype,
                                  Female_family_ID = Family_ID,
                                  female_matings = matings,
                                  breeding = breeding)]
      # note that population only contains living individuals so we don't need to filter for that here
      all_eligible_females <- population[Sex > 0 & matings < 1, 
                                         .(Female_ID = Individual_ID,
                                           Female_mortality_time = Mortality_time,
                                           Female_genotype = Genotype,
                                           Female_family_ID = Family_ID,
                                           female_matings = matings,
                                           breeding = breeding)]
      
      new_males <- population[Sex < 1 & birth_time == t, 
                              .(Male_ID = Individual_ID,
                                Male_mortality_time = Mortality_time,
                                Male_genotype = Genotype,
                                Male_family_ID = Family_ID,
                                male_matings = matings)]
      
      all_eligible_males <- population[Sex < 1 & matings < C,
                                       .(Male_ID = Individual_ID,
                                         Male_mortality_time = Mortality_time,
                                         Male_genotype = Genotype,
                                         Male_family_ID = Family_ID,
                                         male_matings = matings)]
      
      # find mating interactions for new females and join with life history info
      
      if(nrow(new_females) > 0){
        
        new_female_mating_encounter_times <-
          CJ(Female_ID = new_females$Female_ID, 
             Male_ID = all_eligible_males$Male_ID
          )[, 
            .(Female_ID,
              Male_ID,
              Mate_encounter_time_stamp = t + rexp(n = .N, rate = (v/nrow(all_eligible_females))),
              mated = 0,
              inbred_mating = 0,
              reproduced = 0,
              counted = 0)
          ][new_females, on = "Female_ID"
          ][all_eligible_males, on = "Male_ID"]
        
        # add new interactions to the list
        
        # candidate_list <-
        #  rbindlist(list(candidate_list, new_female_mating_encounter_times), use.names = TRUE)
        
      }
      
      # find mating interactions for new males and join with life history info
      if(nrow(new_males)  > 0){  
        new_male_mating_encounter_times <-
          CJ(Female_ID = all_eligible_females$Female_ID, 
             Male_ID = new_males$Male_ID
          )[, 
            .(Female_ID,
              Male_ID,
              Mate_encounter_time_stamp = t + rexp(n = .N, rate = (v/nrow(all_eligible_females))),
              mated = 0,
              inbred_mating = 0,
              reproduced = 0,
              counted = 0)
          ][all_eligible_females, on = "Female_ID"
          ][new_males, on = "Male_ID"]
      }
      
      # add new individuals to the list
      
      candidate_list <-
        unique(rbindlist(list(candidate_list, 
                              new_female_mating_encounter_times,
                              new_male_mating_encounter_times), use.names = TRUE), 
               by = c("Female_ID", "Male_ID")
               # update the reproduced column in the candidate list 
        )[mated > 0 & breeding > 0 & reproduced < 1, reproduced := 1]
    }
    
    # Update the Individual_ID counter
    Individual_ID_counter <- max(population$Individual_ID)
    Family_ID_counter <- max(population$Family_ID)
    
    print(paste0("Reproduction from ", new_mated_breeders, " breeders, ", current_breeders,
                 " breeders alive, time = ", round(t, 2)))
    
    
    # Calculate the frequency of the i allele, quit early if i fixes or goes extinct
    #prop_i <- calc_prop_inbreeding_allele(population, heterozygous_genotype, homozygous_genotype)
    prop_i <- allele_freq_finder(population, 
                                 homozygous_genotype = homozygous_genotype, 
                                 heterozygous_genotype = heterozygous_genotype,
                                 sex_homozygous = sex_homozygous) 
    
    # for testing change the invasion success criteria from fixation to an intermediate freq. Change back for final sim
    #if(prop_i > 0.999 | prop_i < 0.0001) keep_going <- FALSE
    if(prop_i > 0.4 | prop_i < 0.0001) keep_going <- FALSE
    
    
    # Increment t by a small time step
    t <- t + 0.1
  }
  
  # Print the simulation results
  #list(population, candidate_list, prop_i)
  parameters[row, ] %>% mutate(I_frequency = prop_i)
}
```

## Run the simulation

```{r, eval=FALSE}

x <- 
  continuous_time_simulation(row = 1,
                             parameters = parameters,
                             expression = 1,
                             chromosome = "W",
                             inheritance_scheme = offspring_genotypes_W,
                             allele_freq_finder = calc_prop_hemizygous_inbreeding_allele,
                             heterozygous_genotype = NA,
                             homozygous_genotype = "Z_OW_I",
                             sex_homozygous = NA)

map_dfr(1:50, continuous_time_simulation, parameters = parameters, inheritance_scheme = offspring_genotypes_autosome,
                             heterozygous_genotype = "A_IA_O",
                             homozygous_genotype = "A_IA_I")

x %>% glimpse()
```

# Session information

```{r}
sessionInfo() %>% pander
```




