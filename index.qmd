---
title: "When not to avoid inbreeding: a gene's eye view perspective"
author: "Thomas Keaney, Arvid Agren and Hanna Kokko"
execute: 
  warning: false

format:
  html:
      theme: Minty # browse these here: https://quarto.org/docs/output-formats/html-themes.html
      max-width: 1800px # adjust if your plots don't fit or you want more or less whitespace
      toc: true # do you want a table of contents, by default it floats as you scroll
      toc-location: left # where should it be displayed
      toc-title: "Sections" 
      code-fold: true # fold code up for neater display
      smooth-scroll: true 
      embed-resources: true # output doc contains all info needed to display html    
---

# Load packages

```{r}
library(tidyverse) # for tidy style coding and plotting
library(pander) # for tables
library(kableExtra) # for scrolling tables
library(MetBrewer) # for colour palettes based upon artwork housed at the MET
library(MoMAColors) # for colour palettes based upon artwork housed at MoMA
library(wesanderson) # for colour palettes based on wes anderson movies
library(tidybayes) # for plotting distributions
library(stickylabeller) # labelling facets with strings in ggplot
library(patchwork) # for combining plots 
library(geomtextpath) # for curved plot annotations
library(ggtext) # for markdown syntax in plot labels
library(patchwork)
library(ggnewscale)
```

# The model

## The seminal equation

To model the inclusive fitness gained from an inbred mating, three components that contribute to fitness are required:

1.  The number of offspring produced directly: $n$

2.  The reduction in fitness (number of offspring) due to inbreeding: $-\delta n$

3.  The indirect fitness gain (number of offspring) due to inbreeding: $rn$, where $r$ is the relatedness coefficient

Put together, the inclusive fitness from a single inbred mating is:

$$(1 + r)(1 - \delta)n$$

while fitness from a single outbred mating is simply $n$.

When $(1 + r)(1 - \delta)n \gt n$ selection should favour a preference for inbreeding.

Solving the inequality for $\delta$:

$$\delta \lt \frac{r}{1 + r}$$ which for varying values of $r$ looks like this:

```{r, echo=TRUE}

inbreeding_maximum_function <- function(r){
  r / (1 + r)}


parameters <- expand_grid(r = seq(from = 0, to = 1, by = 0.05),
                          delta = seq(from = 0, to = 1, by = 0.05))

r <- parameters %>% distinct(r)

inbreeding_equilibria <- 
  map_dfr(r, inbreeding_maximum_function) %>% 
  rename(inbreeding_depression = r) %>% 
  bind_cols(r)

inbreeding_equilibria %>% 
  ggplot(aes(x = r, y = inbreeding_depression)) +
  geom_line(linewidth = 0.8) + 
  coord_cartesian(ylim = c(0, 1)) +
  labs(x = '_r_, the relatedness coefficient',
       y = ~delta~'(inbreeding depression)') +
  scale_x_continuous(expand = c(0, 0.009)) + 
  scale_y_continuous(expand = c(0, 0)) +
  theme_bw() +
  theme(text = element_text(size = 14),
        axis.title.x = element_markdown())

# (prop fitness lost)\n that can be tolerated"

```

The parameter space above the curve shows where inbreeding avoidance should evolve, while the parameter space below the curve shows where inbreeding preference should evolve.

## Accounting for sex differences in genetic architecture

As stated above, inclusive fitness in the absence of inbreeding depression is $(1 + r)n$. Here $r$ represents the correlation between genotypes carried by interacting females and males, under the implicit assumption that loci appear equally in both sexes. However, given that there is sexual dimorphism in genetic architecture for many taxa, $r$ does not sufficiently represent the correlation between genotypes for all loci.

To delineate differences in the effect of $r$ for different regions of the genome, we multiply $r$ with a new variable $a$, the probability that a locus present in one sex is also present in the gametes produced by the other. Unlike $r$ which is relative to the population mean relatedness, $a$ is expressed as an absolute value ranging from 0 to 1.

The indirect component of fitness accrued by from an inbred mating becomes

$$ran$$

and inclusive fitness from an inbreeding event becomes

$$(1 + ra)(1 - \delta )n$$

Taking an allele found at a diploid autosomal locus as an example, all of the gametes produced by a relative possess this locus, where they could potentially carry alleles identical by descent. In this case $a = 1$ and the indirect component of inclusive fitness is dictated solely by $r$. The results for this autosomal scenario are presented in Parker (1979), Kokko and Ots (2006) and others who have explored this topic. In contrast, an inbreeding preference allele present at a locus on a Y or W chromosome has no opportunity to propagate any alleles identical by descent through inbreeding, as these chromosomes are not carried by the gametes of the opposite sex mating partner. In this case $a = 0$. However, as inbreeding depression is a result of homozygosity for deleterious recessive alleles throughout the genome, the costs of inbreeding depression are born by all alleles carried by the individual. Conflict over the expression of inbreeding preference between alleles present on autosomes and those present on hemizygous sex chromosomes is immediately clear.

X- or Z-linked loci present an interesting intermediate case, with sex-specific values for $a$. When the inbreeding locus is carried by the sex with homozygous sex chromosomes, $a$ is half that of autosomal loci, whereas it does not depart from the autosomal case when the locus is found within the hemizygous sex. Using loci on the X as an example, those present in a XX female are only found in \~50% of a interacting males gametes, as the remaining 50% carry Y chromosomes (assuming an even primary sex ratio). When an X-linked locus is found in a male, an interacting female's gametes all carry X chromosomes and $a = 1$.

The X/Z situation is made additionally complex because there is an element of frequency dependence to the kin selected benefits. When an inbreeding allele on an autosome is rare, then the chance of a relative carrying two copies is low, whereas when the allele is common, this chance is much higher. Rarity therefore leads to similar fitness outcomes for autosomal and X/Z linked alleles (when present in the hemizygous sex), while commonality of the allele likely roughly equates to the conflicting situation outlined in the above paragraph. However, frequency dependence might not as relevant as I initially expected, because the inbreeding allele becomes very common quickly within families, even whilst rare across the population (first proposed in Fisher, 1930).

**Table 1.** Values of the parameter $a$ for different regions of the genome. $a$ is the one-way probability that a locus carried by one individual is found within the gametes of an opposite sex individual. Note that cytoplasmic chromosomes are assumed to have exclusive maternal inheritance.

```{r}
x <- 
  c(1, # autosomes, X chromosome males or Z chromosome females, haplodiploid both sexes when producing females 
    0, # Y or W chromosome
    0.5 # X chromosome females or Z chromosome males
  )

tibble(`Prob. that opposite sex gametes carry focal locus` = c(1, 0.5, 0),
       `Relevant cases` = c("Autosomes in either sex, X chromosomes in males, Z chromosomes in females, chromosomes in haplodiploids of either sex when reproducing sexually, cytoplasmic chromosomes in males",
                            "X chromosomes in females, Z chromosomes in males",
                            "Y chromosomes in males, W chromosomes in females, cytoplasmic chromosomes in females")) %>% 
  pander(split.cell = 20, split.table = Inf)
```

Once again we can find the condition where breeding with a relative returns greater fitness than an inbreeding avoidance strategy, this time accounting for genetic architecture

$$\delta \lt \frac{ra}{1 + ra}$$

Ignoring frequency dependence for now, we can plot the new slopes produced by varying $r$ and $a$:

```{r}

inbreeding_maximum_function_2 <- function(r, a){
  (r*a / (r*a + 1))}


parameters_2 <- expand_grid(r = seq(from = 0, to = 1, by = 0.01),
                          a = c(0, 0.5, 1))

inbreeding_equilibria_2 <- 
  map2_dfr(parameters_2 %>% select(r), 
           parameters_2 %>% select(a), 
           inbreeding_maximum_function_2) %>% 
  rename(inbreeding_depression = r) %>% 
  bind_cols(parameters_2)

inbreeding_equilibria_2 %>% 
  mutate(a = case_when(a == 0 ~ "a = 0",
                       a == 0.5 ~ "a = 0.5",
                       a == 1 ~ "a = 1")) %>% 
  mutate(a = as.factor(a)) %>% 
  ggplot(aes(x = r, y = inbreeding_depression, linetype = a, label = a)) +
  geom_textline(linewidth = 0.8, size = 5) + 
 # scale_colour_manual(values = c("0" = met.brewer("Kandinsky", 4)[1], "0.5" =  met.brewer("Kandinsky", 4)[2], "1" = met.brewer("Kandinsky", 4)[3])) +
  coord_cartesian(ylim = c(0, 1)) +
  labs(x = '_r_, the relatedness coefficient',
       y = ~delta~'(inbreeding depression)',
       linetype = expression(~italic(a)~', the intersex correlation between loci')) +
  scale_x_continuous(expand = c(0.009, 0)) + 
  scale_y_continuous(expand = c(0.025, 0)) +
  theme_bw() +
  theme(text = element_text(size = 14),
        legend.position = "none",
        axis.title.x = element_markdown())
```

$~$

## Differences between the sexes beyond genetic architecture

Parker's seminal equations:

In his 1979 book chapter, Parker considered the inclusive fitness results of breeding with a relative and identified that females and males should have different tolerances for inbreeding depression. The key departure from the monogamous case is that a cost to future reproductive success is included, with the potential to be greater in females than males.

For males he found that selection would favour inbreeding with a sister (full-sib) who could otherwise outcross when:

$$n(1 - \delta) + rn(1- \delta) - cn \gt rn$$

the first term is the direct number of alleles propagated, the second term is the indirect number of alleles propagated (note that this is weighted by relatedness), the third term is the direct number of alleles that were not directly propagated by the male through outcrossing, and the final opposing term is the number of alleles that would've been transmitted had his sister outcrossed (and he forgone mating).

$c$ is the cost of the present mating, relative to what is lost for a female. This can be considered a ratio of parental investment. When $c = 1$ parental investment in the current bout of reproduction is even between the sexes. Alternatively, if males contribute only sperm to an incestuous mating, the cost of mating is likely very small relative to females i.e. $c = 0$.

We add the $a$ variable to the equation and letting $n = 1$, simplify to

$$(1-\delta) + ra(1-\delta) - c \gt ra$$

We can again find the condition where breeding with a relative returns greater fitness than an inbreeding avoidance strategy:

$$\delta_{male} = \frac{1 - c}{1 + ra}$$

Parker then modelled the condition for monandrous females to prefer incestuous matings when also presented with an outcrossing opportunity.

$$n(1 - \delta) + rn(1-\delta) - crn \gt n$$

which we can write as

$$(1-\delta) + ra(1-\delta) - rac \gt 1$$

the inbreeding depression threshold is

$$\delta_{female} = \frac{ra - rac}{1 + ra}$$

Note that when $c = 0$, this is equivalent to the $\delta$ threshold found in the single mating case.

Plot the relationship between $r$ and $\delta$ for several values of $c$ and $a$

```{r}

Parker_cost_data <- 
  expand_grid(r = seq(from = 0, to = 1, by = 0.01),
              a = c(0, 0.5, 1),
              c = c(0, 0.5, 0.9),
              Sex = c("Female", "Male")) %>% 
  mutate(inbreeding_depression = case_when(Sex == "Female" ~ (r*a - r*a*c) / (r*a + 1),
                                           Sex == "Male" ~ (1 - c) / (r*a + 1)))

  Parker_cost_data %>% 
  mutate(a = as.factor(a)) %>% 
  ggplot(aes(x = r, y = inbreeding_depression, linetype = a, colour = Sex)) +
  geom_line(linewidth = 0.9) + 
  scale_colour_manual(values = c("Female" = met.brewer("Peru1", 6)[2], "Male" =  met.brewer("Peru1", 6)[3])) +
  coord_cartesian(ylim = c(0, 1)) +
  labs(y = expression(delta), 
       x = expression(italic("r")),
       linetype = expression(italic("a"))) +
  scale_x_continuous(expand = c(0.009, 0)) + 
  scale_y_continuous(expand = c(0.01, 0)) +
  facet_wrap(~c, nrow = 3, labeller = label_glue('Male mating investment (c): {c}')) +
  theme_bw() +
  theme(text = element_text(size = 14),
        strip.background = element_rect(fill = "Aliceblue", linewidth = .5))

```

## Plotting sexual and intragenomic conflicts

```{r}
resolution <- 200

parameters <- 
  expand_grid(
    r = seq(0, 1, length = resolution),
    a = c(0, 0.5, 1),
    c = c(0, 0.25, 0.5, 0.75, 1),
    D = seq(0, 1, length = resolution)) # D represents inbreeding depression)

results <-
  parameters %>% 
  mutate(female_inbreeding_fitness = (1-D) + (r*a*(1-D)) - (r*a*c),
         male_inbreeding_fitness = (1-D) + r*a*(1-D) - c,
         female_outbreeding_fitness = 1,
         male_outbreeding_fitness = r*a,
         female_fitness_contrast = female_inbreeding_fitness - female_outbreeding_fitness,
         male_fitness_contrast = male_inbreeding_fitness - male_outbreeding_fitness)

```


### When is inbreeding favoured in each sex?

In the figure below, the dashed lines indicate the level of inbreeding depression that can be tolerated for a given value of $r$. The plot is split into panels by $c$, the cost of mating for males relative to females and $a$, the probability that a locus present in one sex is also present in the gametes produced by the other.

```{r}
pal1 <- met.brewer("OKeeffe1", n=100, direction = -1)
pal2 <- met.brewer("Hiroshige", n=50, direction = -1)
#pal2 <- moma.colors("Avedon", n = 50, direction = 1)
  
Female_plot <-
  results %>%
  filter(c != 0.25, c != 0.75, c != 1) %>% 
  ggplot(aes(x = r, y = D)) +
  geom_blank() +
  geom_raster(aes(fill = female_fitness_contrast)) + 
  stat_contour(aes(z = female_fitness_contrast*100), colour = "black", binwidth = 25,
               breaks = c(-125, -100, -75, -50, -25, 25, 50, 75, 100, 125)) +
  stat_contour(aes(z = female_fitness_contrast*100), colour = "black", breaks = 0,
               linetype = 2) +
  #geom_line(data = female_inbreeding_equilibria, aes(x = r, y = D),
   #         linetype = 3, alpha = 0.5) +
  scale_fill_gradientn(colours = pal1, breaks = c(-1.5, -0.75, 0, 0.75, 1.5), limits = c(-2, 2)) +
  facet_wrap(c ~ a, 
             scales = "free", nrow = 2, strip.position = c("top"),
             labeller = label_glue('c = {`c`}, a = {`a`}')) +
  labs(x = '_r_, the relatedness coefficient',
       y = ~delta~'(inbreeding depression)',
       fill = "Inbreeding fitness",
       title = "A. Alleles present in females") +
  scale_x_continuous(expand = c(0, 0)) + 
  scale_y_continuous(expand = c(0, 0)) + # labels = c(0, 25, 50, 75, 90)) +
  theme(panel.border = element_rect(fill = NA, colour = "black", linewidth = .8),
        strip.background = element_rect(colour = "black", fill = "Aliceblue", linewidth = .8),
        axis.title.x = element_markdown(),
        plot.title = element_text(hjust = 0.5))


Male_plot <-
  results %>%
  filter(c != 0.25, c != 0.75, c != 1) %>% 
  ggplot(aes(x = r, y = D)) +
  geom_blank() +
  geom_raster(aes(fill = male_fitness_contrast)) + 
  stat_contour(aes(z = male_fitness_contrast*100), colour = "black", binwidth = 25,
              breaks = c(-125, -100, -75, -50, -25, 25, 50, 75, 100, 125)) +
  stat_contour(aes(z = male_fitness_contrast*100), colour = "black", breaks = 0,
               linetype = 2) +
  #geom_line(data = female_inbreeding_equilibria, aes(x = r, y = D),
   #         linetype = 3, alpha = 0.5) +
  scale_fill_gradientn(colours = pal1, breaks = c(-1.5, -0.75, 0, 0.75, 1.5), limits = c(-2, 2)) +
  facet_wrap(c ~ a, 
             scales = "free", nrow = 2, strip.position = c("top"),
             labeller = label_glue('c = {`c`}, a = {`a`}')) +
  labs(x = '_r_, the relatedness coefficient',
       y = ~delta~'(inbreeding depression)',
       fill = "Inbreeding fitness",
       title = "B. Alleles present in males") +
  scale_x_continuous(expand = c(0, 0)) + 
  scale_y_continuous(expand = c(0, 0)) + # labels = c(0, 25, 50, 75, 90)) +
  theme(panel.border = element_rect(fill = NA, colour = "black", linewidth = .8),
        strip.background = element_rect(colour = "black", fill = "Aliceblue", linewidth = .8),
        axis.title.x = element_markdown(),
        plot.title = element_text(hjust = 0.5))

Female_plot

Male_plot

```

### When is there intragenomic conflict over inbreeding?

These panels show the parameter space where conflict is expected between alleles on different chromosomes. We find that intragenomic conflict over inbreeding is sex, chromosome and mating system (approximated by $c$) specific. 

```{r, fig.width=9}

Intragenomic_conflict_females <-
  results %>%
  select(1:4, female_fitness_contrast) %>%
  pivot_wider(names_from = a, values_from = female_fitness_contrast) %>% 
  mutate(`Autosomal - X-linked` = `1` - `0.5`,
         `Autosomal - Z-linked` = 0,
         `Autosomal - W-linked & Z-linked - W-linked` = `1` - `0`) %>% 
  pivot_longer(cols = contains("-"), names_to = "contrast", values_to = "intragenomic_conflict") %>% 
  mutate(relationship = case_when(
    contrast == "Autosomal - X-linked" & `1` > 0 & `0.5` > 0 ~
      "Inbreeding favoured at both loci",
    contrast == "Autosomal - X-linked" & `1` < 0 & `0.5` < 0 ~
       "Inbreeding deleterious at both loci",
    
    contrast == "Autosomal - Z-linked" & `1` > 0 ~
      "Inbreeding favoured at both loci",
    contrast == "Autosomal - Z-linked" & `1` < 0 ~
       "Inbreeding deleterious at both loci",
    
    contrast == "Autosomal - W-linked & Z-linked - W-linked" & `1` > 0 & `0` > 0 ~
      "Inbreeding favoured at both loci",
    contrast == "Autosomal - W-linked & Z-linked - W-linked" & `1` < 0 & `0` < 0 ~
       "Inbreeding deleterious at both loci",
    `0` == 0 & `0.5` == 0 & `1` == 0 ~ "Inbreeding deleterious at both loci",  
    .default = "Intragenomic conflict")) %>% 
  mutate(contrast = fct_relevel(contrast, "Autosomal - X-linked", "Autosomal - Z-linked",
                                "Autosomal - W-linked & Z-linked - W-linked")) %>% 
  filter(c != 1, c != 0.75, c != 0.25)  # remove if we want more c values

Intragenomic_conflict_males <-
  results %>%
  select(1:4, male_fitness_contrast) %>%
  pivot_wider(names_from = a, values_from = male_fitness_contrast) %>% 
  mutate(`Autosomal - X-linked` = 0,
         `Autosomal - Z-linked` = `1` - `0.5`,
         `Autosomal - Y-linked & X-linked - Y-linked` = `1` - `0`) %>% 
  pivot_longer(cols = contains("-"), names_to = "contrast", values_to = "intragenomic_conflict") %>% 
  mutate(relationship = case_when(
    contrast == "Autosomal - X-linked" & `1` > 0 ~
      "Inbreeding favoured at both loci",
    contrast == "Autosomal - X-linked" & `1` < 0 ~
       "Inbreeding deleterious at both loci",
    
    contrast == "Autosomal - Z-linked" & `1` > 0 & `0.5` > 0 ~
      "Inbreeding favoured at both loci",
    contrast == "Autosomal - Z-linked" & `1` < 0 & `0.5` < 0 ~
       "Inbreeding deleterious at both loci",
    
    contrast == "Autosomal - Y-linked & X-linked - Y-linked" & `1` > 0 & `0` > 0 ~
      "Inbreeding favoured at both loci",
    contrast == "Autosomal - Y-linked & X-linked - Y-linked" & `1` < 0 & `0` < 0 ~
       "Inbreeding deleterious at both loci",
    `0` == 0 & `0.5` == 0 & `1` == 0 ~ "Inbreeding deleterious at both loci",  
    .default = "Intragenomic conflict")) %>% 
    mutate(contrast = fct_relevel(contrast, "Autosomal - X-linked", "Autosomal - Z-linked",
                                "Autosomal - Y-linked & X-linked - Y-linked")) %>% 
  filter(c != 1, c != 0.75, c != 0.25) # remove if we want more c values
    

make_genomic_conflict_plot <- 
  function(data, enter_title){
    data %>% 
      ggplot(aes(x = r, y = D)) +
      geom_blank() +
      geom_tile(data = data %>% filter(relationship == "Intragenomic conflict"),
                aes(fill = intragenomic_conflict)) + 
      scale_fill_gradientn(colours = pal2, limits = c(-1.2, 1.1), #na.value = "white",
                           labels = c("Strong conflict", -0.5, 0, 0.5, "Strong conflict")) +
      labs(fill = "Intragenomic conflict") +
      new_scale_fill() +
      geom_tile(data = data %>% filter(relationship != "Intragenomic conflict"),
                aes(fill = relationship), alpha = 0.75) +
     # stat_contour(data = data %>% filter(relationship == "Intragenomic conflict"),
      #             aes(z = intragenomic_conflict), colour = "black",
       #     breaks = c(-.10, -.20, -.30, -.40, -.50, -.60, -.70, -.80, -.90, -.100,
        #               .10, .20, .30, .40, .50, .60, .70, .80, .90, .100),
         #   upright = TRUE) +
      #stat_contour(aes(z = intragenomic_conflict*100), colour = "black", breaks = 0,
       #    linetype = 2) +
      scale_fill_manual(values = c("#fbe6c5", "#d2fbd4"), 
                                   labels = c("Inbreeding deleterious at both loci", 
                                              "Inbreeding favoured at both loci")) +
      facet_wrap(contrast~c, nrow = 3,
                 scales = "free", strip.position = c("top"),
                 labeller = label_glue('{`contrast`}\nc = {`c`}')) +
      labs(x = '_r_, the relatedness coefficient',
           y = ~delta~'(inbreeding depression)',
           fill = "Evolutionary concordance",
           title = enter_title) +
      scale_x_continuous(expand = c(0, 0)) + 
      scale_y_continuous(expand = c(0, 0)) + # labels = c(0, 25, 50, 75, 90)) +
      theme(panel.border = element_rect(fill = NA, colour = "black", size = .8),
            panel.grid.minor = element_blank(),
            strip.background = element_rect(colour = "black", fill = "Aliceblue", linewidth = .8),
            axis.title.x = element_markdown(),
            plot.title = element_text(hjust = 0.5))
  }

icf <- make_genomic_conflict_plot(Intragenomic_conflict_females, "A. Intragenomic conflict in females")
icm <- make_genomic_conflict_plot(Intragenomic_conflict_males, "B. Intragenomic conflict in males")

icf

icm #+ plot_layout(guides = "collect")

```

### When is there sexual conflict over inbreeding?

These panels show where loci are expected to be under intralocus sexual conflict over inbreeding preference. In regions of sexual conflict, inbreeding preference is always favoured in males, but has negative fitness consequences if expressed by females (assuming that males invest less into mating than females). 

```{r}

autosomal_data <-
  results %>%
  filter(a == 1, c != 1, c != 0.25) %>% 
  mutate(sexual_conflict = male_fitness_contrast - female_fitness_contrast) %>%
  mutate(relationship = 
           case_when(female_fitness_contrast < 0 & male_fitness_contrast > 0 
                     ~ "Sexual conflict",
                     female_fitness_contrast < 0 & male_fitness_contrast < 0 
                     ~ "Inbreeding deleterious at both loci",
                     female_fitness_contrast > 0 & male_fitness_contrast > 0 
                     ~ "Inbreeding favoured at both loci"),
         Location = "Autosomal") 
  


X_data <- 
  results %>% 
  filter(a == 0.5, c != 1, c != 0.25) %>%  
  select(1:4, contains("female")) %>% 
  rename(a_female = a) %>% # this step makes the join work as intended
  left_join(
    results %>% 
      filter(a == 1, c != 1, c != 0.25) %>% 
      select(1:4, starts_with("male")) %>% 
      rename(a_male = a) # this step makes the join work as intended
  ) %>%
  mutate(sexual_conflict = male_fitness_contrast - female_fitness_contrast) %>% 
  mutate(relationship = 
           case_when(female_fitness_contrast < 0 & male_fitness_contrast > 0 
                     ~ "Sexual conflict",
                     female_fitness_contrast < 0 & male_fitness_contrast < 0 
                     ~ "Inbreeding deleterious at both loci",
                     female_fitness_contrast > 0 & male_fitness_contrast > 0 
                     ~ "Inbreeding favoured at both loci"),
         Location = "X-linked")

Z_data <-
  results %>% 
  filter(a == 1, c != 1, c != 0.25) %>%  
  select(1:4, contains("female")) %>% 
  rename(a_female = a) %>% 
  left_join(
    results %>% 
      filter(a == 0.5, c != 1, c != 0.25) %>% 
      select(1:4, starts_with("male")) %>% 
      rename(a_male = a)
  ) %>% 
  mutate(sexual_conflict = male_fitness_contrast - female_fitness_contrast) %>%
  mutate(relationship = 
           case_when(female_fitness_contrast < 0 & male_fitness_contrast > 0 
                     ~ "Sexual conflict",
                     female_fitness_contrast < 0 & male_fitness_contrast < 0 
                     ~ "Inbreeding deleterious at both loci",
                     female_fitness_contrast > 0 & male_fitness_contrast > 0 
                     ~ "Inbreeding favoured at both loci"),
         Location = "Z-linked")

plotting_data <- bind_rows(autosomal_data, X_data, Z_data)

Sexual_conflict_plot <-
  plotting_data %>%
  ggplot(aes(x = r, y = D)) +
  geom_blank() +
  geom_tile(data = plotting_data %>% filter(relationship == "Sexual conflict"),
            aes(fill = sexual_conflict)) + 
  scale_fill_gradientn(colours = pal2, limits = c(-1.2, 1.1), #na.value = "white",
                       labels = c("Strong conflict, female (+)", -0.5, 
                                  "No conflict", 0.5, "Strong conflict, male (+)")) +
  labs(fill = "Sexual conflict") +
  new_scale_fill() +
  geom_tile(data = plotting_data %>% filter(relationship != "Sexual conflict"),
            aes(fill = relationship), alpha = 0.75) +
  scale_fill_manual(values = c("#fbe6c5", "#d2fbd4"), 
                    labels = c("Inbreeding deleterious at both loci", 
                               "Inbreeding favoured at both loci")) +
  facet_wrap(Location~c, nrow = 3,
             scales = "free", strip.position = c("top"),
             labeller = label_glue('{`Location`}, c = {`c`}')) +
  labs(x = '_r_, the relatedness coefficient',
       y = ~delta~'(inbreeding depression)',
       fill = "Intensity of\nsexual conflict") +
  scale_x_continuous(expand = c(0, 0)) + 
  scale_y_continuous(expand = c(0, 0)) + # labels = c(0, 25, 50, 75, 90)) +
  theme(panel.border = element_rect(fill = NA, colour = "black", size = .8),
        strip.background = element_rect(colour = "black", fill = "Aliceblue", linewidth = .8),
        axis.title.x = element_markdown())
  
Sexual_conflict_plot
```


# The simulation

**A work in progress...**

Parker's $c$ value offers a simple, intuitive way to model the cost of mating for males relative to females. However, other methods better capture the dynamics of real populations, where both sexes also run the risk of going unmated. To incorporate both costs of mating and matelessness, we simulate the invasion of an allele that encodes a preference for inbreeding, for loci on various chromosomes and with different sex-specific expression profiles.

## Build a mating table

Something to think about is how we set genetics to affect the expression of inbreeding tolerance/preference. Things that matter include:

1. do we consider inbreeding expression as the additive result of multiple loci on different chromosomes, or do we consider each case separately.

2. is inbreeding expression binary, a threshold trait or a quantitative, normally distributed trait. The latter would allow us to model evolution towards some maximum. The former cases are simpler to code (particularly the first case) but still allow us to answer a very similar question. 

```{r}

make_mating_table <- function(architecture){
  
  make_offspring <- function(X, Y, type, zygote_freq, architecture){
    tibble(Female_genotype = X,
           Male_genotype = Y,
           type,
           zygote_freq,
           locus_type = architecture)
  }
  
  
  # Set up the  possible mating duo types
  
  #mating_types <- 
   # bind_rows(
      # autosomal
    #  expand_grid(
     #   mother = c("A_IA_I.Female",
      #             "A_IA_O.Female",
       #            "A_OA_O.Female"),
        #father = c("A_IA_I.Male",
         #          "A_IA_O.Male",
          #         "A_OA_O.Male")) %>% 
        #mutate(locus_type = "autosomal"),
      # XY (both can encode inbreeding but they're expressed independently)
      #expand_grid(
       # mother = c("X_IX_I.Female",
        #           "X_IX_O.Female",
         #          "X_OX_O.Female"),
        #father = c("X_IY_I.Male",
         #          "X_IY_O.Male",
          #         "X_OY_I.Male",
           #        "X_OY_O.Male")) %>% 
        #mutate(locus_type = "XY"),
      # ZW (as per the XY case)
     # expand_grid(
      #  mother = c("Z_IW_I.Female",
       #            "Z_IW_O.Female",
        #           "Z_OW_I.Female",
         #          "Z_OW_O.Female"),
        #father = c("Z_IZ_I.Male",
         #          "Z_IZ_O.Male",
          #         "Z_OZ_O.Male")) %>% 
        #mutate(locus_type = "ZW"),
      # cytoplasmic
      #expand_grid(
       # mother = c("C_I.Female",
        #           "C_O.Female"),
        #father = c("C_I.Male",
         #          "C_O.Male")) %>% 
        #mutate(locus_type = "cytoplasmic")
    #) %>% 
    #mutate(locus_type = architecture)
  
  # Specify the possible offspring genotypes for all the potential crosses; we use these for the type argument in the make_offspring function
  
  # autosomal
  
  # II x II
  
  a_genotype_1 <- c("A_IA_I.Female", "A_IA_I.Male")
  
  # II x IO
  
  a_genotype_2 <- c("A_IA_I.Female", "A_IA_I.Male", 
                    "A_IA_O.Female", "A_IA_O.Male")
  
  # II x OO
  
  a_genotype_3 <- c("A_IA_O.Female", "A_IA_O.Male")
  
  # IO x IO
  
  a_genotype_4 <- c("A_IA_I.Female", "A_IA_I.Male", 
                    "A_IA_O.Female", "A_IA_O.Male", 
                    "A_OA_O.Female", "A_OA_O.Male")
  
  # IO x OO
  
  a_genotype_5 <- c("A_IA_O.Female", "A_IA_O.Male",
                    "A_OA_O.Female", "A_OA_O.Male")
  
  # OO x OO
  
  a_genotype_6 <- c("A_OA_O.Female", "A_OA_O.Male")
  
  # XY
  
  
  # II x IY_I
  
  xy_genotype_1 <- c("X_IX_I.Female", "X_IY_I.Male")
  
  # II x IY_O
  
  xy_genotype_2 <- c("X_IX_I.Female", "X_IY_O.Male")
  
  # II x OY_I
  
  xy_genotype_3 <- c("X_IX_O.Female", "X_IY_I.Male")
  
  # II x OY_O
  
  xy_genotype_4 <- c("X_IX_O.Female", "X_IY_O.Male")
  
  # IO x IY_I
  
  xy_genotype_5 <- c("X_IX_I.Female", "X_IY_I.Male",
                     "X_IX_O.Female", "X_OY_I.Male")
  
  # IO x IY_O
  
  xy_genotype_6 <- c("X_IX_I.Female", "X_IX_O.Female", 
                     "X_IY_O.Male", "X_OY_O.Male")
  
  # IO x OY_I
  
  xy_genotype_7 <- c("X_IX_O.Female", "X_IY_I.Male",
                     "X_OX_O.Female", "X_OY_I.Male")
  
  # IO x OY_O
  
  xy_genotype_8 <- c("X_IX_O.Female", "X_IY_O.Male",
                     "X_OX_O.Female", "X_OY_O.Male")
  
  # OO x IY_I
  
  xy_genotype_9 <- c("X_IX_O.Female", "X_OY_I.Male")
  
  # OO x IY_O
  
  xy_genotype_10 <- c("X_IX_O.Female", "X_OY_O.Male")
  
  # OO x OY_I
  
  xy_genotype_11 <- c("X_OX_O.Female", "X_OY_I.Male")
  
  # OO x OY_O
  
  xy_genotype_12 <- c("X_OX_O.Female", "X_OY_O.Male")
  
  # ZW
  
  # IW_I x II
  
  zw_genotype_1 <- c("Z_IW_I.Female", "Z_IZ_I.Male")
  
  # IW_I x IO
  
  zw_genotype_2 <- c("Z_IW_I.Female", "Z_IZ_I.Male", 
                     "Z_OW_I.Female", "Z_IZ_O.Male")
  
  # IW_I x OO
  
  zw_genotype_3 <- c("Z_OW_I.Female", "Z_IZ_O.Male")
  
  # IW_O x II
  
  zw_genotype_4 <- c("Z_IZ_I.Male", "Z_IW_O.Female")
  
  # IW_O x IO
  
  zw_genotype_5 <- c("Z_IZ_I.Male",
                     "Z_IW_O.Female", "Z_IZ_O.Male", 
                     "Z_OW_O.Female")
  
  # IW_O x OO
  
  zw_genotype_6 <- c("Z_IZ_O.Male", "Z_OW_O.Female")
  
  # OW_I X II
  
  zw_genotype_7 <- c("Z_IW_I.Female", "Z_IZ_O.Male")
  
  # OW_I x IO
  
  zw_genotype_8 <- c("Z_IW_I.Female", "Z_IZ_O.Male", 
                     "Z_OW_I.Female", "Z_OZ_O.Male")
  
  # OW_I x OO
  
  zw_genotype_9 <- c("Z_OW_I.Female", "Z_OZ_O.Male")
  
  # OW_O X II
  
  zw_genotype_10 <- c("Z_IW_O.Female", "Z_IZ_O.Male")
  
  # OW_O x IO
  
  zw_genotype_11 <- c("Z_IW_O.Female", "Z_IZ_O.Male", 
                      "Z_OW_O.Female", "Z_OZ_O.Male")
  
  # OW_O x OO
  
  zw_genotype_12 <- c("Z_OW_O.Female", "Z_OZ_O.Male")
  
  # cytoplasmic
  
  # I x I
  # I x O
  
  c_genotype_1 <- c("C_I.Female", "C_I.Male")
  
  # O x O
  # O x I
  
  c_genotype_2 <- c("C_O.Female", "C_O.Male")
  
  
  
  # Now calculate the zygote frequencies for each cross
  
  # autosomal
  
  # even frequency of two offspring genotypes
  
  freq_2 <- rep(0.5, 2)
  
  # even frequency between four offspring types
  
  freq_4 <- rep(0.25, 4)
  
  # when there are 6 offspring genotypes
  
  freq_6 <- c(0.125, 0.125,
              0.25, 0.25,
              0.125, 0.125)
  
  bind_rows(
    list(
      make_offspring("A_IA_I", "A_IA_I", a_genotype_1, freq_2, "autosomal"),
      make_offspring("A_IA_I", "A_IA_O", a_genotype_2, freq_4, "autosomal"),
      make_offspring("A_IA_I", "A_OA_O", a_genotype_3, freq_2, "autosomal"),
      make_offspring("A_IA_O", "A_IA_I", a_genotype_2, freq_4, "autosomal"),
      make_offspring("A_IA_O", "A_IA_O", a_genotype_4, freq_6, "autosomal"),
      make_offspring("A_IA_O", "A_OA_O", a_genotype_5, freq_4, "autosomal"),
      make_offspring("A_OA_O", "A_IA_I", a_genotype_3, freq_2, "autosomal"),
      make_offspring("A_OA_O", "A_IA_O", a_genotype_5, freq_4, "autosomal"),
      make_offspring("A_OA_O", "A_OA_O", a_genotype_6, freq_2, "autosomal"),
      
      make_offspring("X_IX_I", "X_IY_I", xy_genotype_1, freq_2, "XY"),
      make_offspring("X_IX_I", "X_IY_O", xy_genotype_2, freq_2, "XY"),
      make_offspring("X_IX_I", "X_OY_I", xy_genotype_3, freq_2, "XY"),
      make_offspring("X_IX_I", "X_OY_O", xy_genotype_4, freq_2, "XY"),
      make_offspring("X_IX_O", "X_IY_I", xy_genotype_5, freq_4, "XY"),
      make_offspring("X_IX_O", "X_IY_O", xy_genotype_6, freq_4, "XY"),
      make_offspring("X_IX_O", "X_OY_I", xy_genotype_7, freq_4, "XY"),
      make_offspring("X_IX_O", "X_OY_O", xy_genotype_8, freq_4, "XY"),
      make_offspring("X_OX_O", "X_IY_I", xy_genotype_9, freq_2, "XY"),
      make_offspring("X_OX_O", "X_IY_O", xy_genotype_10, freq_2, "XY"),
      make_offspring("X_OX_O", "X_OY_I", xy_genotype_11, freq_2, "XY"),
      make_offspring("X_OX_O", "X_OY_O", xy_genotype_12, freq_2, "XY"),
      
      make_offspring("Z_IW_I", "Z_IZ_I", zw_genotype_1, freq_2, "ZW"),
      make_offspring("Z_IW_I", "Z_IZ_O", zw_genotype_2, freq_4, "ZW"),
      make_offspring("Z_IW_I", "Z_OZ_O", zw_genotype_3, freq_2, "ZW"),
      make_offspring("Z_IW_O", "Z_IZ_I", zw_genotype_4, freq_2, "ZW"),
      make_offspring("Z_IW_O", "Z_IZ_O", zw_genotype_5, freq_4, "ZW"),
      make_offspring("Z_IW_O", "Z_OZ_O", zw_genotype_6, freq_2, "ZW"),
      make_offspring("Z_OW_O", "Z_IZ_I", zw_genotype_7, freq_2, "ZW"),
      make_offspring("Z_OW_O", "Z_IZ_O", zw_genotype_8, freq_4, "ZW"),
      make_offspring("Z_OW_O", "Z_OZ_O", zw_genotype_9, freq_2, "ZW"),
      make_offspring("Z_OW_O", "Z_OZ_O", zw_genotype_10, freq_2, "ZW"),
      make_offspring("Z_OW_O", "Z_OZ_O", zw_genotype_11, freq_4, "ZW"),
      make_offspring("Z_OW_O", "Z_OZ_O", zw_genotype_12, freq_2, "ZW"),
      
      make_offspring("C_I", "CI", c_genotype_1, freq_2, "cytoplasmic"),
      make_offspring("C_I", "CO", c_genotype_1, freq_2, "cytoplasmic"),
      make_offspring("C_O", "CI", c_genotype_2, freq_2, "cytoplasmic"),
      make_offspring("C_O", "CO", c_genotype_2, freq_2, "cytoplasmic")
    )) %>% 
    filter(locus_type == architecture)
}

```

An example of the mating table, for an autosomal locus

```{r}
make_mating_table("autosomal") %>% 
  rename(zygote_type = type) %>% 
  kable() %>% 
  kable_styling() %>% 
  scroll_box(height = "500px")
```


## Create the starting population

Following Ekrem and Kokko (2023), we find the reproductive lifespans of `N` diploid individuals in a sexually reproducing population to initialise the simulation. Mortality events are drawn from an exponential distribution with $\mu_F$ and $\mu_M$ for females (`female_death_rate`) and males (`male_death_rate`) respectively. The chance of mortality is therefore constant across the reproductive lifespan for each sex. $\mu_F = \mu_M = 0.2$ in the simulation run documented here.

Each individual possesses an inbreeding locus with two possible alleles. The `A_1` allele encodes inbreeding avoidance, whereas the `A_2` allele encodes inbreeding tolerance. We assume that the invading A_2 allele is dominant, such that any individuals carrying the allele express inbreeding tolerance (we can relax this assumption once I have it coded and working). 

```{r}

# build the function to find individual lifespans

build_starting_pop <-
  function(seed, pop_size, death_rate, Sex){
    set.seed(seed)
    # death times are drawn from an exponential distribution  
    rexp(n = pop_size, rate = death_rate) %>% 
      as_tibble() %>%
      rename(Lifespan = value) %>% 
      mutate(alive = "YES",
             Sex = Sex,
             Enter_time = 0,
             Mortality_time = round(Lifespan + Enter_time, 3),
             Genotype = "A_OA_O")}
  
# code the initial mutational event (this is out of date but still helpful)

#Females_mutation_event <-
 # Females %>% 
#  mutate(allele_1 = case_when(Individual_ID == sample_n(Female_lifespan, 1) %>% pull(Individual_ID) ~ "A_OA_I",
 #                             .default = genotype))
#Males_mutation_event <-
 # Males %>% 
#  mutate(allele_1 = case_when(Individual_ID == sample_n(Male_lifespan, 1) %>% pull(Individual_ID) ~ "A_OA_I",
  #                            .default = genotype))

# this might work better

#candidate_list <- candidate_list %>% mutate(mated = case_when(row_number() %in% c(1, 6) ~ "YES", .default = mated))

```

## Create a candidate list of mating events

With individual reproductive lifespans known, we can then calculate time stamps for every possible female-male encounter for this set of individuals. For each focal male, the time to finding each specific female is drawn from a negative exponential distribution, with rate $\frac{v}{N/2}$. $v$ represents the search efficiency of males in the population, where higher values indicate more efficient mate finding. The end result is a complete schedule of female-male interactions across the generation's reproductive lifespan.

Here, we set `N=1000` and find the encounter time for the $500^2$ possible female-male encounters.

$v$ is one of the parameters that we can vary to change the risk of an individual going unmated. Here, we create candidate lists of mating events where $v = 1$, $v =10$, $v = 100$ and $v = 1000$ (where v = 100 equates to a search efficiency equal to the rate of mortality when $N = 1000)$.

```{r}

candidate_timestamp_finder <-
  function(seed, Female_candidate_IDs, Male_candidate_IDs, encounters, v){
    set.seed(seed)
    expand_grid(Female_ID = Female_candidate_IDs,
                Male_ID = Male_candidate_IDs) %>% 
      bind_cols(
        rexp(n = encounters, rate = (v/(Female_pop_size))) %>%
          as_tibble() %>% 
          rename(Mate_encounter_time_stamp = value) %>% 
          mutate(#v = as.factor(v),
                 fitness = 1,
                 mated = "NO",
                 female_matings = 0,
                 male_matings = 0)
      ) 
  }

#candidate_timestamp_finder(1, 1:4, 5:9, 20, 1)
```


Death triggers replacement by a new breeding individual, assuming that there is >=1 successfully mated female in the population to produce this individual. If there are multiple mated females, the new individual is produced via a loaded lottery, where the probability of parentage is 1 / number of mated females, multiplied by the females relative direct fitness.

There is a carrying capacity version that adds a row whenever the population falls below carrying capacity. Currently, it's commented out because it behaves strangely. Compare the two methods to see this weird behaviour. 

## Build the main simulation function

**Updating the function**

```{r}
# set parameters to build starting population

Starting_pop_size <- 10

Female_pop_size <- Starting_pop_size*0.5

Male_pop_size <- Starting_pop_size*0.5

Female_death_rate <- 0.2

Male_death_rate <- 0.2
```

```{r, eval=FALSE}

#IT NEARLY WORKS

#Latest error: can't compute indices. A problem for tomorrow.

# at 0.15 time it breaks...which is when two individuals are recruited at once.

continuous_time_simulation(C = 2, v = 10, death_rate = 1, time_end = 0.15)

continuous_time_simulation <- function(C, 
                                       v,
                                       death_rate,
                                       time_end){
  
  # we need this so that t is correctly matched to Mortality_time
  
  tolerance <- 0.005
  
  # Initialize the timer t to 0
  t <- 0
  
  # create the starting population
  
  starting_population <- 
    build_starting_pop(seed = 1, pop_size = Female_pop_size, 
                       death_rate = death_rate, "Female") %>% 
    bind_rows(build_starting_pop(seed = 2, pop_size = Male_pop_size, 
                                 death_rate = death_rate, "Male")) %>% 
    mutate(Individual_ID = 1:n(),
           time = 0,
           matings = 0) %>% 
    select(Individual_ID, Sex, Genotype, alive, Enter_time, Lifespan, Mortality_time, matings, time)
  
  # create sex specific tibbles that can be matched to the mating timestamps
  
  female_population <-
    starting_population %>% 
    filter(Sex == "Female") %>% 
    mutate(Female_ID = Individual_ID) %>% 
    rename(Female_mortality_time = Mortality_time,
           Female_alive = alive,
           Female_genotype = Genotype)
  
  male_population <-
    starting_population %>% 
    filter(Sex == "Male") %>% 
    mutate(Male_ID = Individual_ID) %>% 
    rename(Male_mortality_time = Mortality_time,
           Male_alive = alive,
           Male_genotype = Genotype)
  
  # Initialize the Individual_ID counter
  
  Individual_ID_counter <- Starting_pop_size + 1
  
  # Create the initial candidate list of mating interactions
  
  initial_females <- starting_population %>% filter(Sex == "Female") %>% pull(Individual_ID)
  
  initial_males <- starting_population %>% filter(Sex == "Male") %>% pull(Individual_ID)
  
  candidate_list <- 
    candidate_timestamp_finder(seed = 3,
                               Female_candidate_IDs = initial_females,
                               Male_candidate_IDs = initial_males,
                               encounters = Female_pop_size*Male_pop_size,
                               v = 10) %>% 
    # join important genetic and life history info
    left_join(female_population %>% 
                select(Female_ID, Female_mortality_time, Female_alive, Female_genotype),
              by = "Female_ID") %>% 
    
    left_join(male_population %>% 
                select(Male_ID, Male_mortality_time, Male_alive, Male_genotype),
              by = "Male_ID") %>% 
    mutate(time = 0)
  

  # With the initial population and mating schedule ready to go, start the timer and let the simulation run.      In short, time progresses and events with predetermined time stamps occur. These events trigger new           actions which can lead to the production of new breeding individuals which have their own timeline of         predetermined events and interactions.

  while (t <= time_end) {
    
    # the simulation tracks the population via two dataframes. The first holds info about the individuals           in the population, while the second holds info on encounters between males and females in the                 population
    
    starting_population <-
      starting_population %>%
      # update the time and check if anyone dies
      mutate(time = t,
             alive = if_else(Mortality_time - time <= tolerance, "NO", alive))
    
    # with the extant population determined, the next step is to determine if reproduction occurs and by         whom.
    
    # determine whether any female-male encounters result in mating
    
    candidate_list <- candidate_list %>%
      #update the time and find the extant pop
      mutate(time = t,
             Female_alive = if_else(Female_mortality_time <= time, "NO", Female_alive),
             Male_alive = if_else(Male_mortality_time <= time, "NO", Male_alive)) %>%
      # uncomment next line for testing - remove when happy
      #mutate(mated = case_when(row_number() %in% c(1, 2, 11, 16) ~ "YES", .default = mated))
      # determine whether mating occurs
      mutate(mated = case_when(
        # does the encounter happen
        (Mate_encounter_time_stamp - time) < tolerance &
          Female_alive == "YES" &
          Male_alive == "YES" &
          # are both individuals receptive
          female_matings == 0 &
          male_matings <= C ~ "YES",
        .default = mated))
    
    # update the mating tally for each individual
     
    candidate_list <- candidate_list %>%
      group_by(Female_ID) %>% 
      mutate(female_matings = sum(mated != "NO")) %>% 
      ungroup() %>%
      group_by(Male_ID) %>% 
      mutate(male_matings = sum(mated != "NO")) %>% 
      ungroup() 
    
    # make sure two matings haven't taken place - this happens when a female is receptive and meets two males       at the same time. There is a rare occurrence but without this check and change it breaks the simulation
    
    if(nrow(candidate_list %>% filter(female_matings > 1)) > 0){
      
      over_the_limit_female_matings <- 
        candidate_list %>% 
        filter(female_matings > 1 & mated == "YES") %>% 
        group_by(Female_ID) %>% 
        sample_n(1) %>% 
        mutate(mated = "NO") %>% 
        ungroup()
      
      # remove impossible two places at once matings
      
      candidate_list <- rows_update(candidate_list, over_the_limit_matings, by = c("Female_ID", "Male_ID"))
    }
    
    if(nrow(candidate_list %>% filter(female_matings > 1)) > 0){
      over_the_limit_male_matings <-
        candidate_list %>% 
        filter(male_matings > C & mated == "YES") %>% 
        group_by(Male_ID) %>% 
        sample_n(n() - C) %>% 
        mutate(mated = "NO") %>% 
        ungroup()
      
      # remove impossible two places at once matings
      
      candidate_list <- rows_update(candidate_list, over_the_limit_matings, by = c("Female_ID", "Male_ID"))
      
    }
    
     # re-update the mating tally for each individual
    candidate_list <- candidate_list %>%
      group_by(Female_ID) %>% 
      mutate(female_matings = sum(mated != "NO")) %>% 
      ungroup() %>%
      group_by(Male_ID) %>% 
      mutate(male_matings = sum(mated != "NO")) %>% 
      ungroup()
    
    # add mating tally to starting_population
    starting_population <-
      rows_update(starting_population, 
                  
                  candidate_list %>% 
                    select(1:2, female_matings, male_matings) %>%
                    pivot_longer(cols = 1:2, values_to = "Individual_ID") %>%
                    distinct(Individual_ID, .keep_all = T) %>% 
                    mutate(matings = case_when(name == "Female_ID" ~ female_matings,
                                               name == "Male_ID" ~ male_matings)) %>% 
                    select(Individual_ID, matings),
                  by = "Individual_ID")
      
    
    # check how many extant females have mated
    
    mated_pairs <- length(which(candidate_list$mated == "YES" & candidate_list$Female_alive == "YES"))
    
    # Get the current population size 
    
    current_pop_size <- length(which(starting_population$alive == "YES"))
    
    # If the population is below carrying capacity and there are mated females ready to reproduce, start reproduction
    
    if (current_pop_size < Starting_pop_size & mated_pairs > 0) {
      
      # select mating pairs to produce offspring, weighted by fitness. Each pair can produce one offspring
      
      chosen_mating_pairs <- 
        candidate_list %>% 
        filter(mated == "YES" & Female_alive == "YES") %>% 
        slice_sample(n = Starting_pop_size - current_pop_size, weight_by = fitness, replace = FALSE) %>%
        # change mating status for chosen pairs from "YES" to reproduced
        mutate(mated = "Reproduced")
      
      # update the candidate list so that these pairs are not falsely chosen again (repro occurs once from     `   a mating)
      
      candidate_list <- 
        rows_update(candidate_list, chosen_mating_pairs, by = c("Female_ID", "Male_ID"))
      
      # get pertinent info for offspring - genotype, birth time, lifespan, mortality time 
      
      new_recruits <-
        # use the mating table to find the offspring genotype produced by chosen mated pair
        make_mating_table("autosomal") %>% 
        rename(zygote_type = type) %>%
        # filter the table to just the zygotes possible from the chosen pairs
        inner_join(chosen_mating_pairs, relationship = "many-to-many") %>% 
        # for each pair select a zygote genotype and sex, following Mendelian inheritance
        group_by(Female_ID, Male_ID) %>% 
        slice_sample(n = 1, weight_by = zygote_freq) %>%
        ungroup() %>% 
        select(zygote_type) %>% 
        separate_wider_delim(zygote_type, names = c("Genotype", "Sex"), delim = ".") %>% 
        bind_cols(tibble(Individual_ID = Individual_ID_counter:(Individual_ID_counter + 
                                                        (Starting_pop_size - current_pop_size) - 1),
               time = t,
               Enter_time = time,
               Lifespan = rexp(n = Starting_pop_size - current_pop_size, rate = death_rate),
               alive = "YES",
               Mortality_time = Enter_time + Lifespan,
               matings = 0))
      
      
       #tibble(Individual_ID = Individual_ID_counter:(Individual_ID_counter + 
        #                                                (Starting_pop_size - current_pop_size) - 1),
         #      time = t,
          #     Enter_time = time,
           #    Lifespan = rexp(n = Starting_pop_size - current_pop_size, rate = 1),
            #   alive = "YES",
             #  Mortality_time = Enter_time + Lifespan)
      
      
      
      
      
      
      
      # add new rows to the starting_population
      
      starting_population <- bind_rows(starting_population, new_recruits)
      
      # add new individuals to the candidate list, 
      
      new_females <- new_recruits %>% filter(Sex == "Female") %>% 
        rename(Female_ID = Individual_ID,
               Female_mortality_time = Mortality_time,
               Female_alive = alive,
               Female_genotype = Genotype,
               female_matings = matings) %>% 
        select(-c(Sex, Enter_time, Lifespan))
      
      new_males <- new_recruits %>% filter(Sex == "Male") %>% 
        rename(Male_ID = Individual_ID,
               Male_mortality_time = Mortality_time,
               Male_alive = alive,
               Male_genotype = Genotype,
               male_matings = matings) %>% 
        select(-c(Sex, Enter_time, Lifespan))
      
      # find the number of each sex in the population, which we'll need to generate encounter times 
      # for new offspring
      
    Female_pop_size <- length(starting_population %>% 
                                filter(Sex == "Female" & alive == "YES") %>% 
                                row_number())
    
    Male_pop_size <- length(starting_population %>% 
                                filter(Sex == "Male" & alive == "YES") %>% 
                                row_number())
      
      # find mating interactions for new females and join with other life history info
      
    if(nrow(new_females) > 0){
      new_female_mating_encounter_times <-
                expand_grid(Male_ID = starting_population %>% 
                      filter(Sex == "Male" & alive == "YES") %>% pull(Individual_ID),
                    Female_ID = new_females %>% pull(Female_ID)) %>% 
        bind_cols(tibble(
          Mate_encounter_time_stamp = rexp(n = nrow(new_females) * Male_pop_size, rate = v),
          fitness = 1,
          mated = "NO")) %>% 
        left_join(starting_population %>% 
                    filter(Sex == "Male") %>% 
                    distinct(Individual_ID,  .keep_all = T) %>% 
                    rename(Male_ID = Individual_ID,
                           Male_mortality_time = Mortality_time,
                           Male_alive = alive,
                           Male_genotype = Genotype,
                           male_matings = matings) %>% 
                    # here is the problem - these need to be imported from the existing candidate list
                    #mutate(male_matings = 0) %>% 
                    select(-c(Sex, Lifespan, Enter_time, time)),
                  by = "Male_ID") %>% 
        left_join(new_females, by = "Female_ID") 
      
      # add them to the list
      
      candidate_list <-
        candidate_list %>% 
        bind_rows(new_female_mating_encounter_times)
    }
      
      # find mating interactions for new males
      
    if(nrow(new_males > 0)){
      new_male_mating_encounter_times <-
        expand_grid(Male_ID = new_males %>% pull(Male_ID),
                    Female_ID = starting_population %>% 
                      filter(Sex == "Female" & alive == "YES") %>% pull(Individual_ID)) %>% 
        bind_cols(tibble(
          Mate_encounter_time_stamp = rexp(n = nrow(new_males) * Female_pop_size, rate = v),
          fitness = 1,
          mated = "NO")) %>%
        left_join(starting_population %>% 
                    filter(Sex == "Female") %>% 
                    distinct(Individual_ID, .keep_all = T) %>% 
                    rename(Female_ID = Individual_ID,
                           Female_mortality_time = Mortality_time,
                           Female_alive = alive,
                           Female_genotype = Genotype,
                           female_matings = matings) %>% 
                    # here is the problem
                    #mutate(Female_matings = 0) %>% 
                    select(-c(Sex, Lifespan, Enter_time, time)),
                  by = "Female_ID") %>% 
        left_join(new_males, by = "Male_ID")
        
        # add them to the list
        
        candidate_list <-
          candidate_list %>% 
          bind_rows(new_male_mating_encounter_times) %>%
          # this is hacky but it stops new pairs getting added twice when there are new males and 
          # females at the same time 
          distinct(Male_ID, Female_ID, .keep_all = T)
      }
      
      
    candidate_list <-
      rows_update(candidate_list, chosen_mating_pairs, by = c("Female_ID", "Male_ID"))
    
      # Update the Individual_ID counter
      Individual_ID_counter <- Individual_ID_counter + (Starting_pop_size - current_pop_size)
    }
    
    # Increment 't' by a small time step (e.g. 0.01)
    t <- t + 0.01
  }
  
  # Print the simulation results
  list(starting_population, candidate_list)
}
```

# Miscellaneous notes

**The costs of mating**

-   Inbreeding depression

-   Sperm limitation (or some other form of parental investment that reduces the chance of mating again) - C must vary and be focused on.

**The costs of not mating**

-   Matelessness. Currently, this is why increasing $C$ reduces the tolerance towards inbreeding depression. Females foregoing reproduction with a relative are more likely to find a receptive male later in the cycle when $C$ is large.

# Session information

```{r}
sessionInfo() %>% pander
```




