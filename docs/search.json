[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "When not to avoid inbreeding: a gene’s eye view perspective",
    "section": "",
    "text": "Code\nlibrary(tidyverse) # for tidy style coding and plotting\nlibrary(pander) # for tables\nlibrary(MetBrewer) # for colour palettes based upon artwork housed at the met\nlibrary(wesanderson) # for colour palettes based on wes anderson movies\nlibrary(tidybayes) # for plotting distributions\nlibrary(stickylabeller) # labelling facets with strings in ggplot\nlibrary(patchwork) # for combining plots \nlibrary(geomtextpath) # for curved plot annotations"
  },
  {
    "objectID": "index.html#load-packages",
    "href": "index.html#load-packages",
    "title": "When not to avoid inbreeding: a gene’s eye view perspective",
    "section": "",
    "text": "Code\nlibrary(tidyverse) # for tidy style coding and plotting\nlibrary(pander) # for tables\nlibrary(MetBrewer) # for colour palettes based upon artwork housed at the met\nlibrary(wesanderson) # for colour palettes based on wes anderson movies\nlibrary(tidybayes) # for plotting distributions\nlibrary(stickylabeller) # labelling facets with strings in ggplot\nlibrary(patchwork) # for combining plots \nlibrary(geomtextpath) # for curved plot annotations"
  },
  {
    "objectID": "index.html#the-basic-equations",
    "href": "index.html#the-basic-equations",
    "title": "When not to avoid inbreeding: a gene’s eye view perspective",
    "section": "The basic equations",
    "text": "The basic equations\nOur basic equation includes three parameters\n\n\\(n\\) the number of offspring produced directly\nThe loss in fitness (number of offspring) due to inbreeding: \\(-\\delta n\\)\nThe indirect fitness gain (number of offspring) due to inbreeding: \\(rn\\), where \\(r\\) is the relatedness coefficient\n\nPut together, the inclusive fitness from a single inbred mating in a monogamous mating system is:\n\\[(1 + r)(1 - \\delta)n\\]\nwhile fitness from a single outbred mating is simply\n\\[n\\]\nwhen \\((1 + r)(1 - \\delta)n \\gt n\\) selection should favour a preference for inbreeding.\nSolving the inequality for \\(\\delta\\):\n\\[\\delta \\lt \\frac{r}{1 + r}\\] which for varying values of \\(r\\) looks like this:\n\n\nCode\ninbreeding_maximum_function &lt;- function(r){\n  r / (1 + r)}\n\n\nparameters &lt;- expand_grid(r = seq(from = 0, to = 1, by = 0.05),\n                          delta = seq(from = 0, to = 1, by = 0.05))\n\nr &lt;- parameters %&gt;% distinct(r)\n\ninbreeding_equilibria &lt;- \n  map_dfr(r, inbreeding_maximum_function) %&gt;% \n  rename(inbreeding_depression = r) %&gt;% \n  bind_cols(r)\n\ninbreeding_equilibria %&gt;% \n  ggplot(aes(x = r, y = inbreeding_depression)) +\n  geom_line(linewidth = 0.8) + \n  coord_cartesian(ylim = c(0, 1)) +\n  labs(x = expression(~italic(r)~', the relatedness coefficient'),\n       y = ~delta~'(inbreeding depression)') +\n  scale_x_continuous(expand = c(0, 0.009)) + \n  scale_y_continuous(expand = c(0, 0)) +\n  theme_bw() +\n  theme(text = element_text(size = 14))\n\n\n\n\n\nCode\n# (prop fitness lost)\\n that can be tolerated\"\n\n\nThe parameter space above the curve shows where inbreeding avoidance should evolve, while the parameter space below the curve shows where inbreeding preference should evolve."
  },
  {
    "objectID": "index.html#add-a-heritability-like-moderator-variable",
    "href": "index.html#add-a-heritability-like-moderator-variable",
    "title": "When not to avoid inbreeding: a gene’s eye view perspective",
    "section": "Add a ‘heritability-like’ moderator variable",
    "text": "Add a ‘heritability-like’ moderator variable\nAs stated above, inclusive fitness where there is no inbreeding depression is \\((1 + r)n\\).\nHowever, for \\(rn\\) to influence the evolutionary response, an allele present in the focal individual must also have some potential to be carried by the interacting individual. Here \\(r\\) represents the correlation between genotypes carried by interacting females and males, specific to loci that appear equally in both sexes (e.g. loci on autosomes). However, given that there is sexual dimorphism in genetic architecture for many taxa, \\(r\\) does not sufficiently represent the correlation between genotypes for all loci.\nTo delineate differences in the effect of \\(r\\) for different regions of the genome, we moderate the effect of \\(r\\) by multiplying it with a new variable \\(a\\), the probability that a locus present in one sex is also present in the other. Unlike \\(r\\) which is relative to the population mean relatedness, \\(a\\) is expressed as an absolute value ranging from 0 to 1.\nThe indirect component of fitness accrued by from an inbred mating becomes\n\\[(1 + ra)n\\]\nThe indirect fitness benefit is therefore moderated by a product of the correlation between alleles carried by two individuals and the correlation between loci carried by two individuals. Both correlations must be non-zero in order for their to be an evolutionary response to kin selection. Taking an allele found at a diploid autosomal locus as an example, a relative carries two copies of this locus, both of which could potentially contain alleles identical by descent. In this case \\(a = 1\\) and the evolutionary response to kin selection is dictated solely by \\(r\\). The results for this autosomal scenario are presented in Parker (1979), Kokko and Ots (2006) and others who have explored this topic.\nIn contrast, an inbreeding preference allele present at a locus on an Y or W chromosome has no opportunity to propagate any alleles identical by descent through inbreeding, as these chromosomes are not carried by the opposite sex mating partner. In this case \\(a = 0\\). However, as inbreeding depression is the result of homozygosity for deleterious reccessive alleles throughout the genome, the costs of inbreeding depression remains the same. Conflict over the expression of inbreeding preference between alleles present on autosomes and those present on hemizygous sex chromosomes is immediately clear.\nX- or Z-linked loci present an interesting intermediate case, with sex-specific effects. The intersex correlation between loci is half that of autosomal loci for the sex with homozygous sex chromosomes, whereas it does not depart from the autosomal case when expressed in the hemizygous sex. Using loci on the X as an example, those expressed in a female are only found in ~50% of a interacting males gametes\\(^*\\), as the remaining 50% carry Y chromosomes (assuming an even primary sex ratio). When an X-linked locus is found in a male, an interacting female’s gametes all carry X chromosomes and the one-way intersex correlation between loci = 1.\nThe X/Z situation is made additionally complex because there is an element of frequency dependence to the kin selected benefits. When an inbreeding allele on an autosome is rare, then the chance of a relative carrying two copies is low, whereas when the allele is common, this chance is much higher. Rarity therefore leads to similar fitness outcomes for autosomal and X/Z linked alleles (when present in the hemizygous sex), while commonality of the allele likely roughly equates to the conflicting situation outlined in the above paragraph.\n\\(^*\\) thinking about \\(a\\) as the correlation between loci present in the focal individual and those present in a randomly chosen gamete of the interacting individual might be the best way forward.\nTable 1. Values of the parameter \\(a\\) for different regions of the genome. \\(a\\) is the one-way intersex correlation between loci present in interacting individuals. Note that mitochondria are the only endosymbiont I’ve included, because of the sex ratio distortion caused by many of the others, which could lead to intermediate values of \\(a\\).\n\n\nCode\nx &lt;- \n  c(1, # autosomes, X chromosome males or Z chromosome females, haplodiploid both sexes when producing females \n    0, # Y or W chromosome\n    0.5 # X chromosome females or Z chromosome males\n  )\n\ntibble(`Intersex correlation between loci (one-way)` = c(1, 0.5, 0),\n       `Relevant cases` = c(\"Autosomes in either sex, X chromosomes in males, Z chromosomes in females, chromosomes in haplodiploids of either sex when reproducing sexually, mitochondrial chromosomes in males\",\n                            \"X chromosomes in females, Z chromosomes in males\",\n                            \"Y chromosomes in males, W chromosomes in females, mitochondrial chromosomes in females\")) %&gt;% \n  pander(split.cell = 20, split.table = Inf)\n\n\n\n\n\n\n\n\n\nIntersex correlation between loci (one-way)\nRelevant cases\n\n\n\n\n1\nAutosomes in either sex, X chromosomes in males, Z chromosomes in females, chromosomes in haplodiploids of either sex when reproducing sexually, mitochondrial chromosomes in males\n\n\n0.5\nX chromosomes in females, Z chromosomes in males\n\n\n0\nY chromosomes in males, W chromosomes in females, mitochondrial chromosomes in females\n\n\n\n\n\nThe inclusive fitness from an inbreeding event becomes\n\\[(1 + ra)(1 - \\delta )n\\]\nOnce again we can find the condition where breeding with a relative returns greater fitness than an inbreeding avoidance strategy, this time accounting for genetic architecture\n\\[\\delta \\lt \\frac{ra}{1 + ra}\\] Ignoring frequency dependence for now, we can plot the new slopes produced by varying \\(r\\) and \\(a\\):\n\n\nCode\ninbreeding_maximum_function_2 &lt;- function(r, a){\n  (r*a / (r*a + 1))}\n\n\nparameters_2 &lt;- expand_grid(r = seq(from = 0, to = 1, by = 0.01),\n                          a = c(0, 0.5, 1))\n\ninbreeding_equilibria_2 &lt;- \n  map2_dfr(parameters_2 %&gt;% select(r), \n           parameters_2 %&gt;% select(a), \n           inbreeding_maximum_function_2) %&gt;% \n  rename(inbreeding_depression = r) %&gt;% \n  bind_cols(parameters_2)\n\ninbreeding_equilibria_2 %&gt;% \n  mutate(a = case_when(a == 0 ~ \"a = 0\",\n                       a == 0.5 ~ \"a = 0.5\",\n                       a == 1 ~ \"a = 1\")) %&gt;% \n  mutate(a = as.factor(a)) %&gt;% \n  ggplot(aes(x = r, y = inbreeding_depression, linetype = a, label = a)) +\n  geom_textline(linewidth = 0.8, size = 5) + \n # scale_colour_manual(values = c(\"0\" = met.brewer(\"Kandinsky\", 4)[1], \"0.5\" =  met.brewer(\"Kandinsky\", 4)[2], \"1\" = met.brewer(\"Kandinsky\", 4)[3])) +\n  coord_cartesian(ylim = c(0, 1)) +\n  labs(x = expression(~italic(r)~', the relatedness coefficient'),\n       y = ~delta~'(inbreeding depression)',\n       linetype = expression(~italic(a)~', the intersex correlation between loci')) +\n  scale_x_continuous(expand = c(0.009, 0)) + \n  scale_y_continuous(expand = c(0.025, 0)) +\n  theme_bw() +\n  theme(text = element_text(size = 14),\n        legend.position = \"none\")\n\n\n\n\n\n\\(~\\)"
  },
  {
    "objectID": "index.html#differences-between-the-sexes-beyond-genetic-architecture",
    "href": "index.html#differences-between-the-sexes-beyond-genetic-architecture",
    "title": "When not to avoid inbreeding: a gene’s eye view perspective",
    "section": "Differences between the sexes beyond genetic architecture",
    "text": "Differences between the sexes beyond genetic architecture\nParker’s original equations:\nIn his 1979 book chapter, Parker considered the inclusive fitness results of breeding with a relative and identified that females and males should have different tolerances for inbreeding depression.\nFor males he found that selection would favour inbreeding with a sister (full-sib) who could otherwise outcross when:\n\\[n(1 - \\delta) + rn(1- \\delta) - cn \\gt rn\\]\nthe first term is the direct number of offspring alleles propagated, the second term is the indirect number of alleles propagated (note that this is weighted by relatedness), the third term is the direct number of alleles that were not directly propagated by the male through outcrossing and the final opposing term is the number of alleles that would’ve been transmitted had his sister outcrossed (and he forgone mating).\n\\(c\\) is the cost of the present mating, relative to what is lost for a female. This can be considered a ratio of parental investment. When \\(c = 1\\) parental investment in the current bout of reproduction is even between the sexes. Alternatively, if males contribute only sperm to an incestuous mating, the cost of mating is likely very small relative to females i.e. \\(c = 0\\).\nWe add the \\(a\\) variable to the equation and letting \\(n = 1\\), simplify to\n\\[(1-\\delta) + ra(1-\\delta) - c \\gt ra\\]\nWe can again find the condition where breeding with a relative returns greater fitness than an inbreeding avoidance strategy:\n\\[\\delta_{male} = \\frac{1 - c}{1 + ra}\\]\nParker then modelled the condition for females to prefer incestuous matings when also presented with an outcrossing opportunity.\n\\[n(1 - \\delta) + rn(1-\\delta) - crn \\gt n\\] which we can write as\n\\[(1-\\delta) + ra(1-\\delta) - rac \\gt 1\\]\nthe inbreeding depression threshold is\n\\[\\delta_{female} = \\frac{ra - rac}{1 + ra}\\] Note that when \\(c = 0\\), this is equivalent to the \\(\\delta\\) threshold found by Kokko and Ots (2006).\nPlot the relationship between \\(r\\) and \\(\\delta\\) for several values of \\(c\\) and \\(a\\)\n\n\nCode\n# note: map2 can only handle two arguments, so for now I set c = 0\n\nParker_cost_data &lt;- \n  expand_grid(r = seq(from = 0, to = 1, by = 0.01),\n              a = c(0, 0.5, 1),\n              c = c(0, 0.5, 0.9),\n              Sex = c(\"Female\", \"Male\")) %&gt;% \n  mutate(inbreeding_depression = case_when(Sex == \"Female\" ~ (r*a - r*a*c) / (r*a + 1),\n                                           Sex == \"Male\" ~ (1 - c) / (r*a + 1)))\n\n  Parker_cost_data %&gt;% \n  mutate(a = as.factor(a)) %&gt;% \n  ggplot(aes(x = r, y = inbreeding_depression, linetype = a, colour = Sex)) +\n  geom_line(linewidth = 0.9) + \n  scale_colour_manual(values = c(\"Female\" = met.brewer(\"Peru1\", 6)[2], \"Male\" =  met.brewer(\"Peru1\", 6)[3])) +\n  coord_cartesian(ylim = c(0, 1)) +\n  labs(y = expression(delta), \n       x = expression(italic(\"r\")),\n       linetype = expression(italic(\"a\"))) +\n  scale_x_continuous(expand = c(0.009, 0)) + \n  scale_y_continuous(expand = c(0.01, 0)) +\n  facet_wrap(~c, nrow = 3, labeller = label_glue('Male mating investment (c): {c}')) +\n  theme_bw() +\n  theme(text = element_text(size = 14),\n        strip.background = element_rect(fill = \"Aliceblue\", linewidth = .5))"
  },
  {
    "objectID": "index.html#quantifying-the-costs-of-mating-and-not-mating-using-simulation",
    "href": "index.html#quantifying-the-costs-of-mating-and-not-mating-using-simulation",
    "title": "When not to avoid inbreeding: a gene’s eye view perspective",
    "section": "Quantifying the costs of mating (and not mating) using simulation",
    "text": "Quantifying the costs of mating (and not mating) using simulation\nParker’s \\(c\\) value offers a simple, intuitive way to model the cost of mating for males relative to females. However, other methods better capture the dynamics of real populations, where both sexes also run the risk of going unmated. To incorporate both costs of mating and matelessness, we simulate the fitness consequences of following an inbreeding preference or avoidance strategy in a sexually reproducing population where the opportunity for mating is finite. Specifically, we simulate fitness under both conditions for every individual in the population, where each individual is considered independently.\nA very important point is that we consider a population where the resident strategy is to accept mating with a relative. Our simulation therefore estimates the condition required for inbreeding avoidance to invade. One consequence of inbreeding avoidance is an increased risk of going unmated for both sexes when they forego mating with a relative, particularly when the cost of mating for males is large, or search efficiency is low.\n\nProduce a sample of lifespans\nFollowing Ekrem and Kokko (2023), we simulate the reproductive lifespans of N individuals in a single generation. We assume all individuals enter the breeding pool at arbitrary time zero and that from this point onwards, mortality events are drawn from an exponential distribution with \\(\\mu_F\\) and \\(\\mu_M\\) for females (female_death_rate) and males (male_death_rate) respectively. The chance of mortality is therefore constant across the reproductive lifespan for each sex. For simplicity, \\(\\mu_F = \\mu_M = 0.2\\) in the simulation run documented here.\n\n\nCode\n# set some basic parameters that likely won't change\n\nPopulation_size &lt;- 2000\n\nFemale_death_rate &lt;- 0.2\n\nMale_death_rate &lt;- 0.2\n\nn &lt;- 1 # avg progeny produced as a result of mating event \n\n# build the function to find individual lifespans\n\nlifespan_sampler &lt;-\n  function(seed, pop_size, death_rate, Sex){\n    set.seed(seed)\n    # death times are drawn from an exponential distribution  \n    rexp(n = pop_size, rate = death_rate) %&gt;% \n      as_tibble() %&gt;%\n      mutate(Individual_ID = as.factor(1:n()),\n             Sex = Sex)\n  }\n\nMale_lifespan &lt;- \n  lifespan_sampler(seed = 1, pop_size = Population_size/2, \n                   death_rate = Female_death_rate, Sex = \"Male\") %&gt;% \n  rename(Male_ID = Individual_ID,\n         Male_lifespan = value)\n\nFemale_lifespan &lt;- \n  lifespan_sampler(seed = 2, pop_size = Population_size/2, \n                   death_rate = Male_death_rate, Sex = \"Female\") %&gt;% \n  rename(Female_ID = Individual_ID,\n         Female_lifespan = value)\n\n\nA sample of N = 1000 female reproductive lifespans is shown below.\n\n\nCode\nFemale_lifespan %&gt;% \n  ggplot(aes(x = Female_lifespan)) +\n  stat_halfeye(fill = met.brewer(\"VanGogh3\", n = 8)[3], .width = c(0.66, 0.95), alpha = 1,\n               point_interval = \"median_qi\", point_fill = \"white\", \n               shape = 21, point_size = 4, stroke = 1.5) +\n  labs(y = \"Relative frequency\", subtitle = \"Death rate = 0.2\",\n       x = expression('Female reproductive lifespan (Time,'~italic(t)~')')) +\n  scale_x_continuous(expand = c(0, 0)) + \n  #scale_y_continuous(expand = c(0, 0)) + \n  theme_bw() + \n  theme(panel.background = element_rect(fill='transparent'), #transparent panel bg\n        plot.background = element_rect(fill='transparent', color=NA), #transparent plot bg\n        panel.grid.minor.x = element_blank(),\n        legend.position = \"none\", #transparent legend panel\n        text = element_text(size=14))\n\n\n\n\n\n\n\nCreate a candidate list of mating events\nWith individual reproductive lifespans known, we can then calculate time stamps for every possible female-male encounter for this set of individuals. This process follows mass action law, where the population-wide rate of female-male encounters at any time point, \\(t\\), is equal to the female density multiplied by the male density at any time \\(t\\), scaled by a constant \\(v\\). v represents the search efficiency of males in the population, where higher values indicate more efficient mate finding. For each focal male, the time to finding each specific female is drawn from a negative exponential distribution, with rate \\(\\frac{v}{N/2}\\). The end result is a complete schedule of female-male interactions across the breeding cycle.\nHere, we set N=2000 and find the encounter time for the \\(1000^2\\) possible female-male encounters.\nv is one of the parameters that we can vary to change the risk of an individual going unmated. Here, we create candidate lists of mating events where \\(v = 1\\), \\(v =10\\), \\(v = 100\\) and \\(v = 1000\\) (where this last value equates to a search efficiency five times the death rate when population size = 2000).\n\n\nCode\nFemale_pop_size &lt;- Population_size*0.5\nMale_pop_size &lt;- Population_size*0.5\n\ncandidate_timestamp_finder &lt;-\n  function(seed, candidates, v){\n    set.seed(seed)\n    expand_grid(Female_ID = as.factor(1:Female_pop_size),\n                Male_ID = as.factor(1:Male_pop_size)) %&gt;% \n      bind_cols(\n        rexp(n = candidates, rate = (v/(Female_pop_size))) %&gt;%\n          as_tibble() %&gt;% \n          rename(Mate_encounter_time_stamp = value) %&gt;% \n          mutate(v = as.factor(v))\n      ) %&gt;% \n      left_join(Male_lifespan %&gt;% select(-Sex), by = \"Male_ID\") %&gt;% \n      left_join(Female_lifespan %&gt;% select(-Sex), by = \"Female_ID\")\n  }\n\n# create candidate lists\n\ncandidate_list1 &lt;- \n  candidate_timestamp_finder(seed = 3, candidates = Female_pop_size*Male_pop_size,\n                             v = 1)\n\ncandidate_list10 &lt;- \n  candidate_timestamp_finder(seed = 3, candidates = Female_pop_size*Male_pop_size,\n                             v = 10)\n\ncandidate_list100 &lt;- \n  candidate_timestamp_finder(seed = 3, candidates = Female_pop_size*Male_pop_size,\n                             v = 100)\n\ncandidate_list1000 &lt;- \n  candidate_timestamp_finder(seed = 3, candidates = Female_pop_size*Male_pop_size,\n                             v = 1000)\n\n\nThe plots below show the distribution of candidate mating encounters, trimmed to only show encounters set to occur within the maximum reproductive lifespan of females. Note that mate searching is very inefficient when \\(v = 1\\) or \\(v = 10\\), giving the appearance of a constant number of encounters over time, irrespective of the density of potential mates.\n\n\nCode\nbind_rows(candidate_list1, candidate_list10, candidate_list100, candidate_list1000) %&gt;% \n  filter(Mate_encounter_time_stamp &lt; max(Female_lifespan)) %&gt;% \n  ggplot(aes(x = Mate_encounter_time_stamp, y = as.factor(v))) +\n  stat_halfeye(fill = met.brewer(\"VanGogh3\", n = 8)[3], .width = c(0.66, 0.95), alpha = 1,\n               point_interval = \"median_qi\", point_fill = \"white\", \n               shape = 21, point_size = 4, stroke = 1.5) +\n  labs(x= \"Time of female-male encounters in population\",\n       y = expression('Mate searching efficiency, '~italic(v))) +\n  scale_x_continuous(expand = c(0, 0)) + \n  #scale_y_continuous(expand = c(0, 0)) + \n  theme_bw() + \n  theme(panel.background = element_rect(fill='transparent'), #transparent panel bg\n        plot.background = element_rect(fill='transparent', color=NA), #transparent plot bg\n        panel.grid.minor.x = element_blank(),\n        legend.position = \"none\", #transparent legend panel\n        text = element_text(size=14))\n\n\n\n\n\n\n\nTrim candidates to create the mating schedule\nNext, we trim the list of encounters down to the realised number of mating events that occur in the population. First, we remove the temporally impossible encounters that are set to occur after the death of one of the interacting individuals.\nFor simplicity, we assume that females are monandrous and that while males can mate with multiple females, each mating has an associated cost. Examples of such costs include sperm-limitation, courtship displays that diminish condition or post-copulatory investment of resources into reproduction via mate guarding or parental care. We simulate this cost by setting a maximum limit, \\(C\\) for the number of matings a male can attain. Low values of \\(C\\) indicate that mating is costly, whereas high values indicate that a male’s future mating prospects are relatively unaffected by a current mating opportunity. Virgin females are therefore receptive to mating with the first receptive male they encounter (with one important exception; see below) but otherwise unreceptive, while males are receptive to all matings (with the same exception alluded to above) until attained matings = \\(C\\). Low values of \\(C\\) (especially when paired with small \\(v\\)) increase the likelihood of matelessness.\n\n\nCode\ncandidate_list1 &lt;-\n  candidate_list1 %&gt;% \n  filter(Female_lifespan &gt; Mate_encounter_time_stamp & \n           Male_lifespan &gt; Mate_encounter_time_stamp)\n\ncandidate_list10 &lt;-\n  candidate_list10 %&gt;% \n  filter(Female_lifespan &gt; Mate_encounter_time_stamp & \n           Male_lifespan &gt; Mate_encounter_time_stamp)\n\ncandidate_list100 &lt;-\n  candidate_list100 %&gt;% \n  filter(Female_lifespan &gt; Mate_encounter_time_stamp & \n           Male_lifespan &gt; Mate_encounter_time_stamp)\n\ncandidate_list1000 &lt;- \n  candidate_list1000 %&gt;% \n  filter(Female_lifespan &gt; Mate_encounter_time_stamp & \n           Male_lifespan &gt; Mate_encounter_time_stamp)\n\n\ncandidate_list_set &lt;- list(candidate_list1, candidate_list10, candidate_list100, \n                            candidate_list1000)\n\n# the inputs to this function are a candidate list dataframe to trim and a value of C\n\n# To trim the list, for each female we find the rank order of encounters with the min_rank() function. We then do the same for each male. Using this information we then mark encounters that occur between receptive individuals as a mating event.  \n\ncomplete_mating_schedule &lt;- function(data, C){\n  data %&gt;%\n    group_by(Female_ID) %&gt;% \n    mutate(Female_encounter_order = min_rank(Mate_encounter_time_stamp)) %&gt;% \n    ungroup() %&gt;% \n    group_by(Male_ID) %&gt;% \n    mutate(Male_encounter_order = min_rank(Mate_encounter_time_stamp)) %&gt;%\n    ungroup() %&gt;% \n    mutate(Mating_occurred = case_when(Female_encounter_order == 1 &\n                                         Male_encounter_order &lt;= C ~ \"YES\",\n                                       .default = \"NO\"),\n           C = as.factor(C))\n}\n\n# run the function for each value of C\n\nmating_schedule1 &lt;- candidate_list_set %&gt;%  map_dfr(\\(df) complete_mating_schedule(C = 1, data = df))\nmating_schedule2 &lt;- candidate_list_set %&gt;%  map_dfr(\\(df) complete_mating_schedule(C = 2, data = df))\nmating_schedule3 &lt;- candidate_list_set %&gt;%  map_dfr(\\(df) complete_mating_schedule(C = 3, data = df))\nmating_schedule4 &lt;- candidate_list_set %&gt;%  map_dfr(\\(df) complete_mating_schedule(C = 4, data = df))\nmating_schedule20 &lt;- candidate_list_set %&gt;%  map_dfr(\\(df) complete_mating_schedule(C = 20, data = df))\n\n\nmating_schedule &lt;- bind_rows(mating_schedule1, mating_schedule2, mating_schedule3,\n                             mating_schedule4, mating_schedule20)\n\n\n\n\nImplementing inbreeding\nWe assume that each female’s first potential mating encounter occurs with a relative of relatedness \\(r\\) and all subsequent encounters occur with unrelated individuals (\\(r = 0\\); where relatedness is relative to the mean relatedness in the population). While clearly a simplification of reality, this assumption is not unreasonable, as individuals of many species often start life in the same location as their kin, and may remain in the general proximity of their natal range for much of their lives i.e. many species display high population viscosity.\nTo simulate the fitness consequences of inbreeding, we first consider a scenario where virgin females are not choosy, and therefore when virgin are receptive to mating with their relatives. Males also mate freely with any receptive female, until they reach \\(C\\). We then track the fitness consequences of mating incestuously.\nWe calculate the fitness of an allele present in a female from the incestuous mating as\n\\[n(1 - \\delta) + ran(1- \\delta)\\] and any inclusive fitness gained throughout the remainder of the life cycle as\n\\[ran(C_{realised} - 1)\\]\nwhere \\(C_{realised} - 1\\) is the number of additional matings accrued by the focal male. yep C_realised is a bad name for future reproductive value, but just a placeholder for now\n\n\nCode\nresolution &lt;- 25\n\n# Find interactions where mating occurred - because we are interested in the fitness consequences of choosing to inbreed, only cases where breeding is possible are relevant for the success of the strategy. Note that this trims the dataframe from 4.8 million rows to ~15k.\n\nmatings &lt;- mating_schedule %&gt;% filter(Mating_occurred == \"YES\")\n\n# updated with latest parameters\n\nparameters &lt;- \n  expand_grid(\n    r = seq(0, 1, length = resolution),\n    a = c(0, 0.5, 1), \n    D = seq(0, 1, length = resolution), # D represents inbreeding depression\n    n = 1, # remove eventually if we decide coding as 1 works\n    Female_ID = as.factor(1:Female_pop_size))\n\ninbreeding_fitness &lt;- \n  matings %&gt;% # only breeding females used \n  group_by(Male_ID, v, C) %&gt;% \n  mutate(inbreeding_male_matings = n()) %&gt;% # find the number of time each male mates\n  ungroup() %&gt;%\n  select(Female_ID, Male_ID, inbreeding_male_matings, v, C) %&gt;% \n  left_join(parameters, by = \"Female_ID\", relationship = \"many-to-many\") %&gt;% # add the parameters\n  mutate(fitness_inbred_mating = (1 - D)*n + r*a*(1-D)*n,\n         cyto_male_inbred_fitness = r*a*(1-D)*n, # add the case for cytoplasmic alleles in males\n         # future fitness is accrued by the male relative. The inbreeding_male_matings variable includes the inbred mating, which has already been counted, therefore we subtract 1\n         f_future_fitness = r*a*n*(inbreeding_male_matings - 1),#*(1- c), \n         female_inbred_fitness = fitness_inbred_mating + f_future_fitness,\n         # now male fitness from inbreeding\n         m_future_fitness = n*(inbreeding_male_matings - 1),#*(1 - c),\n         male_inbred_fitness = fitness_inbred_mating + m_future_fitness) %&gt;% \n  rename(Focal_female = Female_ID,\n         Focal_male = Male_ID)\n\n\n\n\nImplementing inbreeding avoidance\nWe now consider a scenario where individuals forego mating with their kin. For each female-male pair that mated incestuously, we calculate fitness when they instead follow an outbreeding strategy by:\n\nRemoving the first receptive mating in each females schedule i.e. inbreeding is avoided.\nRecapitulating the mating schedule (as rejecting a mating opportunity has flow on effects for the population).\nRe-deriving female and male fitness across the parameter space.\n\n\\(w_{female} = n + ran(C_{realised})\\)\n\\(w_{male} = nC_{realised} + ran\\)\nWe complete steps 1-3 for each female-male pair, rather than simply removing all the first matings from the population in a single iteration. This is because we are simulating the fitness consequences of avoiding inbreeding when this strategy is rare, rather than when the entire population does so. The conditions present at the onset of invasion is something to discuss.\nBuild the functions to calculate outbred fitness\n\n\nCode\noutbred_parameters &lt;- expand_grid(r = seq(0, 1, length = resolution),\n                                  a = c(0, 0.5, 1))\n\noutbreeding_fitness_function &lt;- function(female, data, search_efficiency, m_mate_limit){\n  \n  cols &lt;- tibble(female_matings = 0, male_matings = 0) #\n  \n  data %&gt;% \n    filter(v == search_efficiency) %&gt;%\n    mutate(Focal_female = as.character(female), # find the focal female\n           Focal_male = Male_ID[which(Female_ID == Focal_female & \n                                        Mating_occurred == \"YES\")]) %&gt;% # find the focal male  \n    filter(Female_ID != female | Mating_occurred != \"YES\") %&gt;% # remove the mating between focal individuals \n    select(-c(C, Female_encounter_order, Male_encounter_order, Mating_occurred)) %&gt;% \n    complete_mating_schedule(C = m_mate_limit) %&gt;% # recapitulate the mating schedule \n    filter(Female_ID == Focal_female | Male_ID == Focal_male, # find future mating events for the focal individuals\n           Mating_occurred == \"YES\") %&gt;% \n    select(Female_ID, Focal_female, Male_ID, Focal_male, v, C) %&gt;% \n    mutate(Future_mating = case_when(Female_ID == Focal_female ~ \"female_matings\", # identify female future mating \n                                     Male_ID == Focal_male ~ \"male_matings\", # identify male future mating\n                                     .default = \"None\")) %&gt;% # this is a failsafe, not essential\n    add_count(Future_mating, name = \"matings\") %&gt;% # count the future matings\n    distinct(Future_mating, .keep_all = T) %&gt;% # only include one row for each focal pair\n    select(Focal_female, Focal_male, Future_mating, matings, v, C) %&gt;% \n    pivot_wider(names_from = Future_mating, values_from = matings) %&gt;%\n    add_column(!!!cols[!names(cols) %in% names(.)]) %&gt;% # if female_matings or male_matings doesn't exist (0 future matings), add the appropriate column from the cols object\n    add_row(Focal_female = \"0\", Focal_male = \"0\", v = as.character(search_efficiency), # when neither focal finds a new mate, the simulation fails. To stop this we add this placeholder row which we can later delete.\n            C = as.character(m_mate_limit), male_matings = 0, female_matings = 0) %&gt;% \n    expand_grid(outbred_parameters) %&gt;% # add the parameter space which was created above \n    mutate(female_outbred_fitness = n * female_matings + r*a*n*male_matings, # find female fitness\n           male_outbred_fitness = n * male_matings + r*a*n*female_matings,\n           cyto_male_outbred_fitness = 0 * male_matings + r*a*n*female_matings) # find cytoplasmic male fitness\n}\n\n# build a function to add the unmated indviduals to the outbred fitness tibble, we'll need this below\n\nadd_unmated_focals &lt;- function(data, breeder_data){\n  breeder_data %&gt;% \n    anti_join(data) %&gt;% # find the females that are in the original breeder data but not the outbred breeding data\n    expand_grid(outbred_parameters) %&gt;% # fill parameter values for these cases\n    mutate(female_matings = 0,\n           male_matings = 0,\n           female_outbred_fitness = 0,\n           male_outbred_fitness = 0,\n           cyto_male_outbred_fitness = 0) %&gt;% \n    bind_rows(data)\n}\n\n\nRun the functions - this is inefficient but it works for a single gen\n\n\nCode\n# If Run_function = TREU, run the function for the desired parameter space and save to local. If FALSE, just load the results from local\n\nRun_function &lt;- FALSE\n\nif(Run_function){  \n  \n  # Find the breeders for each original mating schedule\n  \n  Breeders &lt;- mating_schedule %&gt;% \n    rename(Focal_female = Female_ID, Focal_male = Male_ID) %&gt;% \n    filter(Mating_occurred == \"YES\") %&gt;%\n    #mutate(Female_ID = as.character(Female_ID)) %&gt;% \n    select(Focal_female, Focal_male, C, v)\n  \n  Breeders1 &lt;- Breeders %&gt;% filter(C == 1, v == 1) \n  \n  list1 &lt;- as.list(Breeders1$Focal_female)\n  \n  Breeders2 &lt;- Breeders %&gt;% filter(C == 1, v == 10) \n  \n  list2 &lt;- as.list(Breeders2$Focal_female)\n  \n  Breeders3 &lt;- Breeders %&gt;% filter(C == 1, v == 100) \n  \n  list3 &lt;- as.list(Breeders3$Focal_female)\n  \n  Breeders4 &lt;- Breeders %&gt;% filter(C == 1, v == 1000) \n  \n  list4 &lt;- as.list(Breeders4$Focal_female)\n  \n  Breeders5 &lt;- Breeders %&gt;% filter(C == 2, v == 1) \n  \n  list5 &lt;- as.list(Breeders5$Focal_female)\n  \n  Breeders6 &lt;- Breeders %&gt;% filter(C == 2, v == 10) \n  \n  list6 &lt;- as.list(Breeders6$Focal_female)\n  \n  Breeders7 &lt;- Breeders %&gt;% filter(C == 2, v == 100) \n  \n  list7 &lt;- as.list(Breeders7$Focal_female)\n  \n  Breeders8 &lt;- Breeders %&gt;% filter(C == 2, v == 1000) \n  \n  list8 &lt;- as.list(Breeders8$Focal_female)\n  \n  Breeders9 &lt;- Breeders %&gt;% filter(C == 3, v == 1) \n  \n  list9 &lt;- as.list(Breeders9$Focal_female)\n  \n  Breeders10 &lt;- Breeders %&gt;% filter(C == 3, v == 10) \n  \n  list10 &lt;- as.list(Breeders10$Focal_female)\n  \n  Breeders11 &lt;- Breeders %&gt;% filter(C == 3, v == 100) \n  \n  list11 &lt;- as.list(Breeders11$Focal_female)\n  \n  Breeders12 &lt;- Breeders %&gt;% filter(C == 3, v == 1000) \n  \n  list12 &lt;- as.list(Breeders12$Focal_female)\n  \n  Breeders13 &lt;- Breeders %&gt;% filter(C == 4, v == 1) \n  \n  list13 &lt;- as.list(Breeders13$Focal_female)\n  \n  Breeders14 &lt;- Breeders %&gt;% filter(C == 4, v == 10) \n  \n  list14 &lt;- as.list(Breeders14$Focal_female)\n  \n  Breeders15 &lt;- Breeders %&gt;% filter(C == 4, v == 100) \n  \n  list15 &lt;- as.list(Breeders15$Focal_female)\n  \n  Breeders16 &lt;- Breeders %&gt;% filter(C == 4, v == 1000) \n  \n  list16 &lt;- as.list(Breeders16$Focal_female)\n  \n  Breeders17 &lt;- Breeders %&gt;% filter(C == 20, v == 1) \n  \n  list17 &lt;- as.list(Breeders17$Focal_female)\n  \n  Breeders18 &lt;- Breeders %&gt;% filter(C == 20, v == 10) \n  \n  list18 &lt;- as.list(Breeders18$Focal_female)\n  \n  Breeders19 &lt;- Breeders %&gt;% filter(C == 20, v == 100) \n  \n  list19 &lt;- as.list(Breeders19$Focal_female)\n  \n  Breeders20 &lt;- Breeders %&gt;% filter(C == 20, v == 1000) \n  \n  list20 &lt;- as.list(Breeders20$Focal_female)\n  \n  C1v1 &lt;- \n    map_dfr(list1, outbreeding_fitness_function, data = mating_schedule1, \n            search_efficiency = 1, m_mate_limit = 1) %&gt;% \n    filter(Focal_female != \"0\") # this step removes the added_row for pairs that both failed to breed.\n  \n  C1v10 &lt;- \n    map_dfr(list2, outbreeding_fitness_function, data = mating_schedule1, \n            search_efficiency = 10, m_mate_limit = 1) %&gt;% \n    filter(Focal_female != \"0\")\n  \n  C1v100 &lt;- \n    map_dfr(list3, outbreeding_fitness_function, data = mating_schedule1, \n            search_efficiency = 100, m_mate_limit = 1) %&gt;% \n    filter(Focal_female != \"0\")\n  \n  C1v1000 &lt;- \n    map_dfr(list4, outbreeding_fitness_function, data = mating_schedule1, \n            search_efficiency = 1000, m_mate_limit = 1) %&gt;% \n    filter(Focal_female != \"0\")\n  \n  C2v1 &lt;- \n    map_dfr(list5, outbreeding_fitness_function, data = mating_schedule2, \n            search_efficiency = 1, m_mate_limit = 2) %&gt;% \n    filter(Focal_female != \"0\")\n  \n  C2v10 &lt;- \n    map_dfr(list6, outbreeding_fitness_function, data = mating_schedule2, \n            search_efficiency = 10, m_mate_limit = 2) %&gt;% \n    filter(Focal_female != \"0\")\n  \n  C2v100 &lt;- \n    map_dfr(list7, outbreeding_fitness_function, data = mating_schedule2, \n            search_efficiency = 100, m_mate_limit = 2) %&gt;% \n    filter(Focal_female != \"0\")\n  \n  C2v1000 &lt;- \n    map_dfr(list8, outbreeding_fitness_function, data = mating_schedule2, \n            search_efficiency = 1000, m_mate_limit = 2) %&gt;% \n    filter(Focal_female != \"0\")\n  \n  C3v1 &lt;- \n    map_dfr(list9, outbreeding_fitness_function, data = mating_schedule3, \n            search_efficiency = 1, m_mate_limit = 3) %&gt;% \n    filter(Focal_female != \"0\")\n  \n  C3v10 &lt;- \n    map_dfr(list10, outbreeding_fitness_function, data = mating_schedule3, \n            search_efficiency = 10, m_mate_limit = 3) %&gt;% \n    filter(Focal_female != \"0\")\n  \n  C3v100 &lt;- \n    map_dfr(list11, outbreeding_fitness_function, data = mating_schedule3, \n            search_efficiency = 100, m_mate_limit = 3) %&gt;% \n    filter(Focal_female != \"0\")\n  \n  C3v1000 &lt;- \n    map_dfr(list12, outbreeding_fitness_function, data = mating_schedule3, \n            search_efficiency = 1000, m_mate_limit = 3) %&gt;% \n    filter(Focal_female != \"0\")\n  \n  C4v1 &lt;- \n    map_dfr(list13, outbreeding_fitness_function, data = mating_schedule4, \n            search_efficiency = 1, m_mate_limit = 4) %&gt;% \n    filter(Focal_female != \"0\")\n  \n  C4v10 &lt;- \n    map_dfr(list14, outbreeding_fitness_function, data = mating_schedule4, \n            search_efficiency = 10, m_mate_limit = 4) %&gt;% \n    filter(Focal_female != \"0\")\n  \n  C4v100 &lt;- \n    map_dfr(list15, outbreeding_fitness_function, data = mating_schedule4, \n            search_efficiency = 100, m_mate_limit = 4) %&gt;% \n    filter(Focal_female != \"0\")\n  \n  C4v1000 &lt;- \n    map_dfr(list16, outbreeding_fitness_function, data = mating_schedule4, \n            search_efficiency = 1000, m_mate_limit = 4) %&gt;% \n    filter(Focal_female != \"0\")\n  \n  C20v1 &lt;- \n    map_dfr(list17, outbreeding_fitness_function, data = mating_schedule20, \n            search_efficiency = 1, m_mate_limit = 20) %&gt;% \n    filter(Focal_female != \"0\")\n  \n  C20v10 &lt;- \n    map_dfr(list18, outbreeding_fitness_function, data = mating_schedule20, \n            search_efficiency = 10, m_mate_limit = 20) %&gt;% \n    filter(Focal_female != \"0\")\n  \n  C20v100 &lt;- \n    map_dfr(list19, outbreeding_fitness_function, data = mating_schedule20, \n            search_efficiency = 100, m_mate_limit = 20) %&gt;% \n    filter(Focal_female != \"0\")\n  \n  C20v1000 &lt;- \n    map_dfr(list20, outbreeding_fitness_function, data = mating_schedule20, \n            search_efficiency = 1000, m_mate_limit = 20) %&gt;% \n    filter(Focal_female != \"0\")\n  \n  #The function above only calculates fitness for individuals where they or their relative successfully mate at least once after foregoing an incestuous mating. However, all individuals producing offspring in the inbreeding acceptance scenario  need to be accounted for in order to evaluate the fitness consequences of inbreeding relative to inbreeding avoidance. Use the add_unmated_focals() function to fix this\n  \n  outbred1 &lt;- add_unmated_focals(C1v1, Breeders1)\n  outbred2 &lt;- add_unmated_focals(C1v10, Breeders2)\n  outbred3 &lt;- add_unmated_focals(C1v100, Breeders3)\n  outbred4 &lt;- add_unmated_focals(C1v1000, Breeders4)\n  outbred5 &lt;- add_unmated_focals(C2v1, Breeders5)\n  outbred6 &lt;- add_unmated_focals(C2v10, Breeders6)\n  outbred7 &lt;- add_unmated_focals(C2v100, Breeders7)\n  outbred8 &lt;- add_unmated_focals(C2v1000, Breeders8)\n  outbred9 &lt;- add_unmated_focals(C3v1, Breeders9)\n  outbred10 &lt;- add_unmated_focals(C3v10, Breeders10)\n  outbred11 &lt;- add_unmated_focals(C3v100, Breeders11)\n  outbred12 &lt;- add_unmated_focals(C3v1000, Breeders12)\n  outbred13 &lt;- add_unmated_focals(C4v1, Breeders13)\n  outbred14 &lt;- add_unmated_focals(C4v10, Breeders14)\n  outbred15 &lt;- add_unmated_focals(C4v100, Breeders15)\n  outbred16 &lt;- add_unmated_focals(C4v1000, Breeders16)\n  outbred17 &lt;- add_unmated_focals(C20v1, Breeders17)\n  outbred18 &lt;- add_unmated_focals(C20v10, Breeders18)\n  outbred19 &lt;- add_unmated_focals(C20v100, Breeders19)\n  outbred20 &lt;- add_unmated_focals(C20v1000, Breeders20)\n  \n  outbreeding_fitness &lt;- \n    bind_rows(outbred1, outbred2, outbred3, outbred4, outbred5, outbred6, outbred7, \n              outbred8, outbred9, outbred10, outbred11, outbred12, outbred13, outbred14,\n              outbred15, outbred16, outbred17, outbred18, outbred19, outbred20)\n  write_csv(outbreeding_fitness, file = \"results/outbreeding.fitness_compact.csv\")\n  \n} else outbreeding_fitness &lt;- read_csv(\"results/outbreeding.fitness_compact.csv\")\n\n\nFinally, we combine the inbreeding_fitness and outbreeding_fitness dataframes. inbreeding_fitness has &gt;115 million rows, which is 50 times as many as outbreeding_fitness, due to the inclusion of \\(\\delta\\) in its explored parameter space.\nWhether selection favours inbreeding at a particular parameter space, in a particular sex, is found by subtracting outbreeding fitness from inbreeding fitness, for each female-male encounter. For each parameter space, we then find the mean value for all interactions.\n\n\nCode\nresults &lt;-\n  inbreeding_fitness  %&gt;% \n  select(-inbreeding_male_matings) %&gt;% \n  left_join(\n    outbreeding_fitness %&gt;% \n      mutate(across(Focal_female:v, ~ as.factor(.x)))) %&gt;%\n  \n  group_by(v, C, D, r, a) %&gt;%\n  summarise(female_inbred_fitness = mean(female_inbred_fitness),\n            male_inbred_fitness = mean(male_inbred_fitness),\n            cyto_male_inbred_fitness = mean(cyto_male_inbred_fitness),\n            female_outbred_fitness = mean(female_outbred_fitness),\n            male_outbred_fitness = mean(male_outbred_fitness),\n            cyto_male_outbred_fitness = mean(cyto_male_outbred_fitness))%&gt;% \n  ungroup() %&gt;% \n  mutate(female_fitness_contrast = female_inbred_fitness - female_outbred_fitness,\n         male_fitness_contrast = male_inbred_fitness - male_outbred_fitness,\n         cyto_male_fitness_contrast = cyto_male_inbred_fitness - cyto_male_outbred_fitness)\n\n\nFind the inbreeding depression threshold for varying levels of \\(r\\), for now discounting \\(a\\)\n\n\nCode\nf_inbreeding_maximum_function &lt;- function(r){\n  r / (1 + r) %&gt;% \n    as_tibble() %&gt;% \n    rename(D = value)}\n\nr &lt;- tibble(r = seq(from = 0, to = 1, by = 0.05))\n\nfemale_inbreeding_equilibria &lt;- \n  map_dfr(r, f_inbreeding_maximum_function) %&gt;% \n  bind_cols(r)\n\nm_inbreeding_maximum_function &lt;- function(r){\n  1 / (1 + r) %&gt;% \n    as_tibble() %&gt;% \n    rename(D = value)}\n\nr &lt;- tibble(r = seq(from = 0, to = 1, by = 0.05))\n\nmale_inbreeding_equilibria &lt;- \n  map_dfr(r, m_inbreeding_maximum_function) %&gt;% \n  bind_cols(r)"
  },
  {
    "objectID": "index.html#plot-the-results",
    "href": "index.html#plot-the-results",
    "title": "When not to avoid inbreeding: a gene’s eye view perspective",
    "section": "Plot the results",
    "text": "Plot the results\n\nWhen is inbreeding favoured in each sex?\n\n\nCode\npal1 &lt;- met.brewer(\"OKeeffe1\", n=100, direction = -1)\npal2 &lt;- met.brewer(\"Hiroshige\", n=50, direction = -1)\n  \nFemale_plot &lt;-\n  results %&gt;%\n  filter(v == 100, C != 2 & C != 4) %&gt;% \n  ggplot(aes(x = r, y = D)) +\n  geom_blank() +\n  geom_raster(aes(fill = female_fitness_contrast)) + \n  stat_contour(aes(z = female_fitness_contrast*100), colour = \"black\", binwidth = 25,\n               breaks = c(-100, -75, -50, -25, 25, 50, 75, 100)) +\n  stat_contour(aes(z = female_fitness_contrast*100), colour = \"black\", breaks = 0,\n               linetype = 2) +\n  geom_line(data = female_inbreeding_equilibria, aes(x = r, y = D),\n            linetype = 3, alpha = 0.5) +\n  scale_fill_gradientn(colours = pal1, breaks = c(-1, -0.5, 0, 0.5, 1), limits = c(-1.5, 1.5)) +\n  facet_wrap(C ~ a, \n             scales = \"free\", nrow = 3, strip.position = c(\"top\"),\n             labeller = label_glue('C = {`C`}, a = {`a`}')) +\n  labs(x = expression(~italic(r)~', the relatedness coefficient'),\n       y = ~delta~'(inbreeding depression)',\n       fill = \"Inbreeding fitness\",\n       subtitle = \"Alleles present in females\") +\n  scale_x_continuous(expand = c(0, 0)) + \n  scale_y_continuous(expand = c(0, 0)) + # labels = c(0, 25, 50, 75, 90)) +\n  theme(panel.border = element_rect(fill = NA, colour = \"black\", linewidth = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8))\n\n\nMale_plot &lt;-\n  results %&gt;%\n  filter(v == 100, C != 2 & C != 4) %&gt;% \n  ggplot(aes(x = r, y = D)) +\n  geom_blank() +\n  geom_raster(aes(fill = male_fitness_contrast)) + \n  stat_contour(aes(z = male_fitness_contrast*100), colour = \"black\", binwidth = 25,\n               breaks = c(-75, -50, -25, 25, 50, 75, 100)) +\n  stat_contour(aes(z = male_fitness_contrast*100), colour = \"black\", breaks = 0,\n               linetype = 2) +\n  geom_line(data = male_inbreeding_equilibria, aes(x = r, y = D),\n            linetype = 3, alpha = 0.5) +\n  scale_fill_gradientn(colours = pal1, breaks = c(-1, -0.5, 0, 0.5, 1), limits = c(-1.5, 1.5)) +\n  facet_wrap(C ~ a, \n             scales = \"free\", nrow = 3, strip.position = c(\"top\"),\n             labeller = label_glue('C = {`C`}, a = {`a`}')) +\n  labs(x = expression(~italic(r)~', the relatedness coefficient'),\n       y = ~delta~'(inbreeding depression)',\n       fill = \"Inbreeding fitness\",\n       subtitle = \"Alleles present in males\") +\n  scale_x_continuous(expand = c(0, 0)) + \n  scale_y_continuous(expand = c(0, 0)) + # labels = c(0, 25, 50, 75, 90)) +\n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8))\n\nFemale_plot\n\n\n\n\n\nCode\nMale_plot\n\n\n\n\n\n\n\nWhen is there intragenomic conflict over inbreeding?\n\n\nCode\nIntragenomic_conflict &lt;-\n  results %&gt;%\n  filter(v == 100, C != 4, C != 1) %&gt;% \n  select(1:5, female_fitness_contrast, male_fitness_contrast) %&gt;%\n  pivot_wider(names_from = a, values_from = c(female_fitness_contrast, male_fitness_contrast)) %&gt;% \n  mutate(intragenomic_conflict_f_0_0.5 = female_fitness_contrast_0.5 - female_fitness_contrast_0,\n         #intragenomic_conflict_f_0.5_1 = female_fitness_contrast_1 - female_fitness_contrast_0.5,\n         intragenomic_conflict_f_0_1 = female_fitness_contrast_1 - female_fitness_contrast_0,\n         intragenomic_conflict_m_0_0.5 = male_fitness_contrast_0.5 - male_fitness_contrast_0,\n         #intragenomic_conflict_m_0.5_1 = male_fitness_contrast_1 - male_fitness_contrast_0.5,\n         intragenomic_conflict_m_0_1 = male_fitness_contrast_1 - male_fitness_contrast_0) %&gt;%\n  pivot_longer(cols = contains(\"intragenomic\"), names_to = \"contrast\", values_to = \"intragenomic_conflict\") %&gt;%\n  mutate(contrast = str_remove(contrast, \"intragenomic_conflict_\")) %&gt;% \n  separate_wider_delim(cols = contrast, delim = \"_\", names = c(\"Sex\", \"a_2\", \"a_1\")) %&gt;% \n  unite(\"contrast\", a_1:a_2) %&gt;% \n    mutate(contrast = case_when(\n    contrast == \"0.5_0\" ~ \"a = 0.5 - a = 0\",\n    contrast == \"1_0\" ~ \"a = 1 - a = 0\")) %&gt;%\n  mutate(intragenomic_conflict = case_when(\n    female_fitness_contrast_0 &lt; 0 & female_fitness_contrast_0.5 &gt; 0 & Sex == \"f\" & contrast == \"a = 0.5 - a = 0\" \n    ~ intragenomic_conflict,\n    female_fitness_contrast_0 &lt; 0 & female_fitness_contrast_1 &gt; 0 & Sex == \"f\" & contrast == \"a = 1 - a = 0\" \n    ~ intragenomic_conflict,\n    male_fitness_contrast_0 &gt; 0 & male_fitness_contrast_0.5 &lt; 0 & Sex == \"m\" & contrast == \"a = 0.5 - a = 0\" \n    ~ intragenomic_conflict,\n    male_fitness_contrast_0 &gt; 0 & male_fitness_contrast_1 &lt; 0 & Sex == \"m\" & contrast == \"a = 1 - a = 0\" \n    ~ intragenomic_conflict,\n    .default = NA)) %&gt;% \n  select(1:4, Sex, contrast, contains(\"intragenomic\")) \n    \n\nmake_genomic_conflict_plot &lt;- \n  function(sex, enter_subtitle){\n    Intragenomic_conflict %&gt;%\n      filter(Sex == sex) %&gt;% \n      #mutate(C = as.numeric(C)) %&gt;% \n      ggplot(aes(x = r, y = D)) +\n      geom_blank() +\n      geom_tile(aes(fill = intragenomic_conflict)) + \n      #stat_contour(aes(z = intragenomic_conflict), colour = \"black\",\n       #     breaks = c(-.10, -.20, -.30, -.40, -.50, -.60, -.70, -.80, -.90, -.100,\n        #               .10, .20, .30, .40, .50, .60, .70, .80, .90, .100),\n         #   upright = TRUE) +\n      #stat_contour(aes(z = intragenomic_conflict*100), colour = \"black\", breaks = 0,\n       #    linetype = 2) +\n      scale_fill_gradientn(colours = pal2, limits = c(-1.25, 1.1), na.value = \"white\",\n                           labels = c(\"Strong conflict\", -0.5, \"No conflict\", 0.5, \"Strong conflict\")) +\n      facet_wrap(C~contrast, nrow = 4,\n                 scales = \"free\", strip.position = c(\"top\"),\n                 labeller = label_glue('contrast: {`contrast`}, C = {`C`}')) +\n      labs(x = expression(~italic(r)~', the relatedness coefficient'),\n           y = ~delta~'(inbreeding depression)',\n           fill = \"Intragenomic conflict\",\n           subtitle = enter_subtitle) +\n      scale_x_continuous(expand = c(0, 0)) + \n      scale_y_continuous(expand = c(0, 0)) + # labels = c(0, 25, 50, 75, 90)) +\n      theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n            strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8))\n  }\n\nmake_genomic_conflict_plot(sex = \"f\", \"Intragenomic conflict in females\")\n\n\n\n\n\nCode\nmake_genomic_conflict_plot(sex = \"m\", \"Intragenomic conflict in males\")\n\n\n\n\n\n\n\nWhen is there sexual conflict over inbreeding?\n\n\nCode\nautosomal_data &lt;-\n  results %&gt;%\n  filter(a == 1, v == 100,C != 4, C != 1) %&gt;% \n  mutate(sexual_conflict = male_fitness_contrast - female_fitness_contrast) %&gt;%\n   mutate(sexual_conflict_updated = \n           if_else(female_fitness_contrast &lt; 0 & male_fitness_contrast &gt; 0, sexual_conflict, NA),\n          Location = \"Autosomal\") \n\nX_data &lt;- \n  results %&gt;% \n  filter(a == 0.5, C != 4, C != 1, v == 100) %&gt;%  \n  select(1:5, contains(\"female\")) %&gt;% \n  rename(a_female = a) %&gt;% # this step makes the join work as intended\n  left_join(\n    results %&gt;% \n      filter(a == 1, C != 4, C != 1, v == 100) %&gt;% \n      select(1:5, starts_with(\"male\")) %&gt;% \n      rename(a_male = a) # this step makes the join work as intended\n  ) %&gt;%\n  mutate(sexual_conflict = male_fitness_contrast - female_fitness_contrast) %&gt;% \n  mutate(sexual_conflict_updated = \n           if_else(female_fitness_contrast &lt; 0 & male_fitness_contrast &gt; 0, sexual_conflict, NA),\n         Location = \"X\")\n\nZ_data &lt;-\n  results %&gt;% \n  filter(a == 1, C != 4, C != 1, v == 100) %&gt;%  \n  select(1:5, contains(\"female\")) %&gt;% \n  rename(a_female = a) %&gt;% left_join(\n    \n    results %&gt;% \n      filter(a == 0.5, C != 4, C != 1, v == 100) %&gt;% \n      select(1:5, starts_with(\"male\")) %&gt;% \n      rename(a_male = a)\n  ) %&gt;% \n  mutate(sexual_conflict = male_fitness_contrast - female_fitness_contrast) %&gt;%\n    mutate(sexual_conflict_updated = \n             if_else(female_fitness_contrast &lt; 0 & male_fitness_contrast &gt; 0, sexual_conflict, NA),\n           Location = \"Z\")\n\n\n\nSexual_conflict_plot &lt;-\n  bind_rows(autosomal_data, X_data, Z_data) %&gt;%\n  ggplot(aes(x = r, y = D)) +\n  geom_blank() +\n  geom_tile(aes(fill = sexual_conflict_updated)) + \n  # stat_contour(aes(z = sexual_conflict_updated), colour = \"black\",\n  #      breaks = c(-.10, -.20, -.30, -.40, -.50, -.60, -.70, -.80, -.90, -.100,\n  #                .10, .20, .30, .40, .50, .60, .70, .80, .90, .100),\n  #    upright = TRUE) +\n  #stat_contour(aes(z = sexual_conflict*100), colour = \"black\", breaks = 0,\n  #    linetype = 2) +\n  scale_fill_gradientn(colours = pal2, limits = c(-1.25, 1.1), na.value = \"white\",\n                       labels = c(\"Strong conflict, female (+)\", -0.5, \n                                  \"No conflict\", 0.5, \"Strong conflict, male (+)\")) +\n  facet_wrap(Location~C, \n             scales = \"free\", strip.position = c(\"top\"),\n             labeller = label_glue('Location: {`Location`}, C = {`C`}')) +\n  labs(x = expression(~italic(r)~', the relatedness coefficient'),\n       y = ~delta~'(inbreeding depression)',\n       fill = \"Intensity of\\nsexual conflict\") +\n  scale_x_continuous(expand = c(0, 0)) + \n  scale_y_continuous(expand = c(0, 0)) + # labels = c(0, 25, 50, 75, 90)) +\n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8))\n  \nSexual_conflict_plot\n\n\n\n\n\n\n\nThe cytoplasmic case\nThe results for cytoplasmic alleles are intuitive. Inbreeding can evolve through selection on either sex, but there is very little sexual antagonism over inbreeding, as selection optimises female fitness in both cases. The extent to which the inbreeding strategy is favoured can vary but the sign will never be opposing.\n\n\nCode\nFemale_cyto_plot &lt;-\n  results %&gt;%\n  filter(v != 10, C != 2 & C != 4, a == 0) %&gt;% \n  ggplot(aes(x = r, y = D)) +\n  geom_blank() +\n  geom_raster(aes(fill = female_fitness_contrast)) + \n  stat_contour(aes(z = female_fitness_contrast*100), colour = \"black\", binwidth = 25,\n               breaks = c(-100, -75, -50, -25, 25, 50, 75, 100)) +\n  stat_contour(aes(z = female_fitness_contrast*100), colour = \"black\", breaks = 0,\n               linetype = 2) +\n  scale_fill_gradientn(colours = pal1, breaks = c(-1, -0.5, 0, 0.5, 1), limits = c(-1.5, 1.5)) +\n  facet_wrap(v ~ C, \n             scales = \"free\", nrow = 3, strip.position = c(\"top\"),\n             labeller = label_glue('C = {`C`}')) +\n  labs(x = expression(~italic(r)~', the relatedness coefficient'),\n       y = ~delta~'(inbreeding depression)',\n       fill = \"Inbreeding fitness\",\n       subtitle = \"Alleles present in females\") +\n  scale_x_continuous(expand = c(0, 0)) + \n  scale_y_continuous(expand = c(0, 0)) + # labels = c(0, 25, 50, 75, 90)) +\n  theme(panel.border = element_rect(fill = NA, colour = \"black\", linewidth = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", size = .8))\n\n\nMale_cyto_plot &lt;-\n  results %&gt;%\n  filter(v != 10, C != 2 & C != 4, a == 1) %&gt;%  \n  ggplot(aes(x = r, y = D)) +\n  geom_blank() +\n  geom_tile(aes(fill = cyto_male_fitness_contrast)) + \n  stat_contour(aes(z = cyto_male_fitness_contrast*100), colour = \"black\", binwidth = 25,\n               breaks = c(-75, -50, -25, 25, 50, 75, 100)) +\n  stat_contour(aes(z = cyto_male_fitness_contrast*100), colour = \"black\", breaks = 0,\n               linetype = 2) +\n  scale_fill_gradientn(colours = pal1, breaks = c(-1, -0.5, 0, 0.5, 1), limits = c(-1.5, 1.5)) +\n  facet_wrap(v ~ C,\n             scales = \"free\", nrow = 3, strip.position = c(\"top\"),\n             labeller = label_glue('C = {`C`}')) +\n  labs(x = expression(~italic(r)~', the relatedness coefficient'),\n       y = ~delta~'(inbreeding depression)',\n       fill = \"Inbreeding fitness\",\n       subtitle = \"Cytoplasmic alleles present in males\") +\n  scale_x_continuous(expand = c(0, 0)) + \n  scale_y_continuous(expand = c(0, 0)) + # labels = c(0, 25, 50, 75, 90)) +\n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", size = .8))\n\nFemale_cyto_plot\n\n\n\n\n\nCode\nMale_cyto_plot"
  },
  {
    "objectID": "notes.html",
    "href": "notes.html",
    "title": "Notes",
    "section": "",
    "text": "Premise outline\nThis project centres around the fate of alleles that encode inbreeding preference / avoidance depending on where they occur within the genome.\nBut the deeper idea is that inbreeding is a ‘selfish action’ where some alleles benefit from helping copies of themselves in other individuals, to the detriment of the broader organism. This detriment occurs because of inbreeding depression, which occurs because of homozygosity at other loci across the genome. Homozygosity causes the expression of recessive deleterious alleles which are otherwise rarely expressed, reducing the number of viable offspring produced by the organism.\nTo represent the broader genome, we can use alleles on hemizygous sex chromosomes, which have no opportunity to be homozygous and thus can gain no benefits of helping a relative gain a breeding opportunity. This broadly aligns with the ‘interests’ of the organism. For example, in an XY system alleles on the Y do not increase the propagation of alleles identical by descent through inbreeding, because females do not carry a Y. An autosomal allele, however, does have the potential to increase the proliferation of its copies by increasing the chance of breeding with a relative. This benefit is somewhat similar to that achieved by meiotic drive allele (clarify your thoughts here).\nA second potential angle is to explore the effect of the sex an allele encoding a preference for inbreeding is expressed in. This is important because the conditions often applicable to expression in a male present a greater parameter space for inbreeding preference (to put it too simply, because males invest less in each mating opportunity than females). Sex-specific effects also interact with hemizygous conditions, because in addition to XY systems, ZW systems exist and suddenly hemizygous chromosomes are present in females.\nSo in sum, there is a likely conflict between alleles on different chromosomes over the tendency to inbreed and there is a second non-mutually exclusive conflict between the sexes over inbreeding tendency. Wow, this is cool.\nThis idea might be deeper still. We point out that alleles on hemizygous sex chromosomes gain no indirect inclusive fitness benefits by mating with kin. The kicker is that inbreeding is just one example of this larger idea. There are no inclusive fitness benefits for alleles that encode any altruistic behaviour towards opposite sex individuals (where one sex possesses a hemizygous sex chromosome).\nSome specific notes from the meeting\n\nHanna’s 2006 paper shows when a preference for inbreeding should or should not be favoured for an autosomal allele, but does not consider other regions of the genome.\nStart with the Parker 1/3 thing, which Hanna and co re-derive. But they implicitly assume that the alleles in question here are on an autosome. We can make the change that they are on a sex chromosome, as stipulated above.\nThe X and Z can also be explored, because of their unusual inheritance dynamics. E.g. the X spends 2/3 of its time in females, but is always expressed in males and vice versa for the W.\nDoes it matter whether the loci that cause inbreeding depression are on the same/different chromosomes as those that encode inbreeding preferences…\nBirds versus mammals, flies versus butterflies etc - different hemizygous sex chromosomes\nUnity breaks down because of inheritance differences\nHamilton 1967 extraordinary sex chromosomes paper is a nice angle here\nHaplodiploidy - this is an extension opportunity.\nI will also try to simulate this question.\n\n\\(~\\)\n\n\n\n\nHanna suggests that the time in, time out continuous framework might not be the best option, as it is not the most intuitive for others.\nPerhaps keeping it simple may be the best way forward - females mate once, males mate multiple times. This produces differences in the opportunity cost of mating between the sexes.\nA discrete time model might work better\nScottish group models the inbreeding problem in helpful ways\nAnother way is to follow the Ekrem paper and simulate in an intelligent way (this method might be particularly fruitful)\nEssentially browse the different ways to approach the problem and follow one you like best.\nModels like our developing one do not consider purging dynamics that should occur if inbreeding becomes common."
  },
  {
    "objectID": "notes.html#project-background-notes",
    "href": "notes.html#project-background-notes",
    "title": "Notes",
    "section": "",
    "text": "Premise outline\nThis project centres around the fate of alleles that encode inbreeding preference / avoidance depending on where they occur within the genome.\nBut the deeper idea is that inbreeding is a ‘selfish action’ where some alleles benefit from helping copies of themselves in other individuals, to the detriment of the broader organism. This detriment occurs because of inbreeding depression, which occurs because of homozygosity at other loci across the genome. Homozygosity causes the expression of recessive deleterious alleles which are otherwise rarely expressed, reducing the number of viable offspring produced by the organism.\nTo represent the broader genome, we can use alleles on hemizygous sex chromosomes, which have no opportunity to be homozygous and thus can gain no benefits of helping a relative gain a breeding opportunity. This broadly aligns with the ‘interests’ of the organism. For example, in an XY system alleles on the Y do not increase the propagation of alleles identical by descent through inbreeding, because females do not carry a Y. An autosomal allele, however, does have the potential to increase the proliferation of its copies by increasing the chance of breeding with a relative. This benefit is somewhat similar to that achieved by meiotic drive allele (clarify your thoughts here).\nA second potential angle is to explore the effect of the sex an allele encoding a preference for inbreeding is expressed in. This is important because the conditions often applicable to expression in a male present a greater parameter space for inbreeding preference (to put it too simply, because males invest less in each mating opportunity than females). Sex-specific effects also interact with hemizygous conditions, because in addition to XY systems, ZW systems exist and suddenly hemizygous chromosomes are present in females.\nSo in sum, there is a likely conflict between alleles on different chromosomes over the tendency to inbreed and there is a second non-mutually exclusive conflict between the sexes over inbreeding tendency. Wow, this is cool.\nThis idea might be deeper still. We point out that alleles on hemizygous sex chromosomes gain no indirect inclusive fitness benefits by mating with kin. The kicker is that inbreeding is just one example of this larger idea. There are no inclusive fitness benefits for alleles that encode any altruistic behaviour towards opposite sex individuals (where one sex possesses a hemizygous sex chromosome).\nSome specific notes from the meeting\n\nHanna’s 2006 paper shows when a preference for inbreeding should or should not be favoured for an autosomal allele, but does not consider other regions of the genome.\nStart with the Parker 1/3 thing, which Hanna and co re-derive. But they implicitly assume that the alleles in question here are on an autosome. We can make the change that they are on a sex chromosome, as stipulated above.\nThe X and Z can also be explored, because of their unusual inheritance dynamics. E.g. the X spends 2/3 of its time in females, but is always expressed in males and vice versa for the W.\nDoes it matter whether the loci that cause inbreeding depression are on the same/different chromosomes as those that encode inbreeding preferences…\nBirds versus mammals, flies versus butterflies etc - different hemizygous sex chromosomes\nUnity breaks down because of inheritance differences\nHamilton 1967 extraordinary sex chromosomes paper is a nice angle here\nHaplodiploidy - this is an extension opportunity.\nI will also try to simulate this question.\n\n\\(~\\)\n\n\n\n\nHanna suggests that the time in, time out continuous framework might not be the best option, as it is not the most intuitive for others.\nPerhaps keeping it simple may be the best way forward - females mate once, males mate multiple times. This produces differences in the opportunity cost of mating between the sexes.\nA discrete time model might work better\nScottish group models the inbreeding problem in helpful ways\nAnother way is to follow the Ekrem paper and simulate in an intelligent way (this method might be particularly fruitful)\nEssentially browse the different ways to approach the problem and follow one you like best.\nModels like our developing one do not consider purging dynamics that should occur if inbreeding becomes common."
  },
  {
    "objectID": "Selfish_inbreeding.html",
    "href": "Selfish_inbreeding.html",
    "title": "Selfish_inbreeding",
    "section": "",
    "text": "I think we can answer our question using the Kokko and Ots framework, but is it the right choice? Given we take a gene’s eye view, is a population genetic model (or if too difficult, a simulation) required.\nKin selection pop-gen models are well developed, by the time in, time out investment into reproduction dynamics is going to require lots of thinking on my behalf.\nThis is my first goal…\n\n\n\nLet’s build a single autosomal locus, bi-allelic model, assuming Hardy-Weinberg equilibrium.\n\nThe \\(A\\) allele is the ‘non-donor’ allele (can be thought of as an allele encoding outbreeding preference). The frequency of this allele is \\(p\\).\nThe \\(a\\) allele is the donor allele (the altruistic allele, which may encode inbreeding preference). The frequency of this allele is \\(q = 1 - p\\).\n\\(1 - h^2\\) is the likelihood that the \\(Aa\\) genotype exhibits the altruistic behaviour. If \\(h^2 = 1\\) then the allele is completely recessive.\n\nThe next step is to find all possible mating types:\n\n\nCode\nmake_mating_table &lt;- function(){#k, normalP1, P1cost, P2cost){\n  \n  make_offspring &lt;- function(X, Y, type, zygote_freq){\n    tibble(mother = X,\n           father = Y,\n           type,\n           zygote_freq)\n  }\n\n  # Set up the 9 possible mating combinations\n  \n  mating_types &lt;- expand_grid(\n    mother = c(\"AA_female\",\n               \"Aa_female\",\n               \"aa_female\"),\n    father = c(\"AA_male\",\n                \"Aa_male\",\n                \"aa_male\"))\n\n\n # Specify the possible offspring genotypes for all the potential crosses; we use these for the type argument in the make_offspring function\n  \n  # AA x AA\n  \n  g0 &lt;- c(\"AA_female\", \"AA_male\")\n  \n  # Aa x AA & AA x Aa\n  \n  g1 &lt;- c(\"AA_female\", \"AA_male\", \"Aa_female\", \"Aa_male\")\n  \n  # aa x AA & AA x aa\n  \n  g2 &lt;- c(\"Aa_female\", \"Aa_male\")\n  \n  # Aa x Aa\n  \n  g3 &lt;- c(\"AA_female\", \"AA_male\", \"Aa_female\", \"Aa_male\", \"aa_female\", \"aa_male\")\n  \n  # Aa x aa & aa x Aa\n  \n  g4 &lt;- c(\"Aa_female\", \"Aa_male\", \"aa_female\", \"aa_male\")\n  \n  # aa x aa\n  \n  g5 &lt;- c(\"aa_female\", \"aa_male\")\n  \n  # Now calculate the zygote frequencies for each cross\n  \n  # even frequency of four offspring types\n  \n  rep25 &lt;- rep(0.25, 4)\n  \n  # even frequency between two offspring types\n  \n  rep5 &lt;- rep(0.5, 2)\n  \n  # Aa * Aa\n  \n  p1 &lt;- c(0.5*0.25,\n          0.5*0.25,\n          0.5*0.5,\n          0.5*0.5,\n          0.5*0.25,\n          0.5*0.25)\n  \n    bind_rows(\n    list(\n      make_offspring(\"AA\", \"AA\", g0, rep5),\n      make_offspring(\"AA\", \"Aa\", g1, rep25),\n      make_offspring(\"AA\", \"aa\", g2, rep5),\n      make_offspring(\"Aa\", \"AA\", g1, rep25),\n      make_offspring(\"Aa\", \"Aa\", g3, p1),\n      make_offspring(\"Aa\", \"aa\", g4, rep25),\n      make_offspring(\"aa\", \"AA\", g2, rep5),\n      make_offspring(\"aa\", \"Aa\", g4, rep25),\n      make_offspring(\"aa\", \"aa\", g5, rep5)\n    )) %&gt;% \n    arrange(mother, father)\n  \n}\n\nmake_mating_table() %&gt;% \n  rename(zygote_type = type) %&gt;% \n  kable() %&gt;% \n  kable_styling() %&gt;% \n  scroll_box(height = \"500px\")\n\n\nThe frequency of each mating type can be generated using the terms of the classic equation:\n\\[(p^2 + 2pq + q^2)^2\\] Note the final square generates the mating combination.\nThe frequencies of each genotype are\n\n\nCode\n(Mating_type_freqs &lt;-\n  tibble(mother = c(\"AA\",\"AA\",\"AA\",\"Aa\",\"Aa\",\"Aa\",\"aa\",\"aa\",\"aa\"),\n         father = c(\"AA\",\"Aa\",\"aa\",\"AA\",\"Aa\",\"aa\",\"AA\",\"Aa\",\"aa\"),\n         frequency = c(\"(p^4)/2\", \"(4p^3*q)/2\", \"(2p^2*2q^2)/2\", \"(4p^3*q)/2\",\n                       \"(4p^2*q^2)/2\", \"(4p*q^3)/2\", \"(2p^2*2q^2)/2\", \"(4p*q^3)/2\",\n                       \"(q^4)/2\"\n                       )) %&gt;% \n  kable() %&gt;% \n    kable_styling())\n\n\n\n\n\n\nThis is a two-step process. First we determine the frequencies of each genotype in the mating population (this could be, for example, after we’ve accounted for inbreeding costs), then we calculate the frequencies of each potential mating combination between these genotypes.\nStep 1 - finding the genotype frequencies in the mating population\nHere we can model an inbreeding depression effect, by changing the viability of different genotypes. I make this a constant for now, to aid my initial understanding, but later this will be one of the key parameters to vary.\nI have also allowed the dominance of \\(a\\) to vary. While inbreeding depression is the result of the increased expression of recessive alleles through homozygosity, partially recessive alleles are likely to be common. When \\(h = 1\\), the \\(a\\) allele is completely recessive.\n\n\nCode\negg_adult_viability_Aa_finder &lt;- function(h){1 - 0.33*(1 - h)}\n\n\n# viability of each genotype \n\negg_adult_viability_AA_female &lt;- 1\n\negg_adult_viability_Aa_female &lt;- egg_adult_viability_Aa_finder(h = 1)\n\negg_adult_viability_aa_female &lt;- 0.67\n\negg_adult_viability_AA_male &lt;- 1\n\negg_adult_viability_Aa_male &lt;- egg_adult_viability_Aa_finder(h = 1)\n\negg_adult_viability_aa_male &lt;- 0.67\n\n\nUsing these parameters, we implement selection, so that each genotype is represented in the mating combinations according to the product of its frequency and its viability, which is determined by inbreeding depression. I assume that mating success is constant across genotypes (this may not be possible if one allele approaches extinction).\nStep 2 - finding the frequency of all potential mating combinations in the mating population\nNext, we model the effect of inbreeding preference on inclusive fitness (direct + indirect fitness). I first assume that individuals are faced with a simultaneous choice situation - between mating with a relative or mating with an unrelated individual.\nFor simplicity at the outset, I assume that inbreeding preference is only expressed in females. To simulate inbreeding preference, females carrying the \\(a\\) allele mate with siblings (those individuals produced by the same parental genotype combination). However, dominance also plays a role here. A proportion \\(1 - h\\) of \\(Aa\\) females express inbreeding preference, whereas a proportion \\(h\\) do not.\nWith the above in mind, I calculate the expected frequencies of each possible ‘mating combination’ (i.e. the combination of the maternal and paternal genotypes) across the population. For singly-mated females with genotype \\(AA\\), the frequency of each mating type is simply given by \\(F_iM_j\\), where \\(F_i\\) and \\(M_j\\) are the female and male parental genotype frequencies, that is they choose mates at random. For females with genotype \\(Aa\\) a proportion \\(1 - h\\) express a preference for inbreeding. For these females, the expected frequencies for each mating type are determined by the parental mating type combination they were produced by. These females randomly choose a mate from a subset of possible genotypes produced by the parental combination e.g. an \\(AA\\) x \\(aa\\) mating will produce a female that will choose to mate with a \\(Aa\\) male (the only possible genotype of her brothers). The proportion \\(h\\) of \\(Aa\\) females not expressing the \\(a\\) allele choose mates at random. Finally, All \\(aa\\) females choose to mate with individuals sired by the same parental genotypes.\n\n\nCode\nfind_mating_type_frequencies &lt;- function(pop, prob_remating_SD, prob_remating_W){\n  \n  # Step 1\n  \n  pop$prop &lt;- pop$prop * pop$egg_adult_viability # here's the selection step \n  pop$prop &lt;- pop$prop / sum(pop$prop) # now restandardise so that the props sum to 1\n  \n  # Step 2\n  \n  # Calculate the frequency of each single-mating combination\n  \n  first_mating_types &lt;- \n    expand_grid(mother = pop$type[str_detect(pop$type, \"female\")], # find all possible mother genotypes\n                father = pop$type[!str_detect(pop$type, \"female\")]) %&gt;% # find all possible father1 genotypes\n    mutate(prop_matings = 0, remating_probability = 0) # make placeholder columns we will fill in below\n  \n  # find genotype frequencies calculated for each sex (mate choice means these will not necessarily be 50:50)\n  \n  female_frequencies &lt;- pop %&gt;% filter(str_detect(type, \"female\")) %&gt;% mutate(prop = prop / sum(prop))\n  male_frequencies &lt;- pop %&gt;% filter(!str_detect(type, \"female\")) %&gt;% mutate(prop = prop / sum(prop))\n  \n  # This next step multiplies the proportion[i] of females with genotype[i] with the proportion[i] of males with genotype[i] \n  \n  for(i in 1:nrow(first_mating_types)){\n    first_mating_types$prop_matings[i] &lt;- female_frequencies$prop[female_frequencies$type == first_mating_types$mother[i]] * \n      male_frequencies$prop[male_frequencies$type == first_mating_types$father1[i]]\n  }\n  \n  # Now we incorporate female remating probabilities (SDSD males assumed to have same effect on females as WW males)\n  \n  first_mating_types$remating_probability &lt;- ifelse(str_detect(first_mating_types$father1, \"WSD\"), prob_remating_SD, prob_remating_W)\n  \n  # Now lets calculate the frequency of each double-mating combination, with the end product being the mating_type_frequency of each mating possibility\n  \n  second_mating_types &lt;- expand_grid(first_mating_types, father2 = c(\"none\", unique(first_mating_types$father1))) %&gt;%\n    mutate(mating_type_freq = 0)\n  \n  # scale the proportion of matings calculated above by the likelihood that these females will mate once\n  \n  for(i in 1:nrow(second_mating_types)){\n    if(second_mating_types$father2[i] == \"none\"){\n      second_mating_types$mating_type_freq[i] &lt;- \n        second_mating_types$prop_matings[i] * # Frequency of females with this value of father1\n        (1 - second_mating_types$remating_probability[i])\n    }\n    \n    # now calculate the frequency of mating tryads for the females that mate twice\n    \n    if(second_mating_types$father2[i] != \"none\"){\n      second_mating_types$mating_type_freq[i] &lt;- \n        second_mating_types$prop_matings[i] * # Frequency of females with this value of father1\n        second_mating_types$remating_probability[i] *\n        male_frequencies$prop[male_frequencies$type == second_mating_types$father2[i]] # pop. freq of the 2nd male type\n    }\n  }\n  \n  second_mating_types %&gt;% # output\n    select(mother, father1, father2, mating_type_freq) %&gt;%\n    # clean up the output by remving redundant info (makes it easier later)\n    mutate(mother = str_remove_all(mother, \"_female\"),\n           father1 = str_remove_all(father1, \"_male\"),\n           father2 = str_remove_all(father2, \"_male\"))\n}\n\n\n\n\n\n\n\n\\(~\\)\nThis is hard, but everything should be in the Kokko and Ots paper\nWe can now directly follow Kokko and Ots (2006), altering the equations where required to reflect the fitness consequences of inbreeding for different chromosomes.\n\n\n\n\n\n\nParameter definitions\n\n\n\n\\(\\delta\\): fraction of offspring lost due to inbreeding (inbreeding depression)\n\\(v_I\\): ‘time in’ reproductive value of individuals of the choosing sex\n\\(w_I\\): ‘time in’ reproductive value of individuals of the opposite sex\n\\(v_O\\): ‘time out’ reproductive value of individuals of the choosing sex\n\\(w_O\\): ‘time out’ reproductive value of individuals of the opposite sex\n\\(M\\): the unrelated mate encounter rate during time in (when sex ratio is unbiased)\n\\(m_v = M \\sqrt{\\beta}\\): the mating rate for the choosy sex\n\\(m_w = \\frac{M}{\\sqrt{\\beta}}\\): the mating rate for the opposite sex\n\\(\\beta\\): the operational sex ratio (males:females)\n\\(a\\): average number of offspring produced from a mating (I think - needs to be found numerically)\n\\(T_v\\): time out duration for choosing sex\n\\(T_w\\): time out duration for opposite sex\n\\(\\mu_{Iv}\\): ‘time in’ mortality risk of individuals of the choosing sex\n\\(\\mu_{Iw}\\): ‘time in’ mortality risk of individuals of the opposite sex\n\\(\\mu_{Ov}\\): ‘time out’ mortality risk of individuals of the choosing sex\n\\(\\mu_{Ow}\\): ‘time out’ mortality risk of individuals of the opposite sex\n\n\nAfter mating, offspring are produced, with a direct fitness benefit of \\[a(v_I + w_I)\\]\n\n\nThe choosing sex can either mate with an unrelated individual or an individual related by \\(r\\).\nMate with unrelated individual: \\(v_O + ro_iw_I + a(v_I + w_1)\\)\nMate with kin: \\(v_O + ro_iw_O + (1 + ro_i)(1 - \\delta)a(v_I + w_1)\\)\nWe continue to frame our study around the value of \\(\\delta\\) that can be tolerated, or put another way, to what extent can inbreeding reduce offspring viability and still be the selected strategy?\nWe therefore rearrange the equation to find the threshold value of \\(\\delta\\) where\n\\[v_O + ro_iw_O + (1 + ro_i)(1 - \\delta)a(v_I + w_1) \\gt v_O + ro_iw_I + a(v_I + w_1)\\]\nto\n\\[\\delta_{sim} = 1 - \\frac{a(v_I + w_I) + ro_i(w_I - w_O)}{a(1 + ro_i)(v_I + w_I)}\\] which can be more neatly expressed as\n\\[\\delta_{sim} = \\frac{a ro_i(v_I + w_I) - ro_i(w_I - w_O)}{a(1 + ro_i)(v_I + w_I)}\\]\n\n\n\nIn this scenario, a choosy individual (note that our models are framed around the strategy adopted by the choosy individuals) encounters a single potential mate, related by \\(r\\). The choosing sex can either mate with this individual or elect not to mate and wait for a future opportunity.\nNot mating produces the inclusive fitness:\n\\[v_I + ro_iw_I\\] Now an inbreeding preference strategy is favoured where\n\\[v_O + ro_iw_O + (1 + ro_i)(1 - \\delta)a(v_I + w_1) \\gt v_I + ro_iw_I\\]\nThus, the threshold \\(\\delta\\) value below which inbreeding is adaptive is\n\\[\\delta_{seq} = 1 - \\frac{(v_I - v_O) + ro_i(w_I - w_O)}{a(1 + ro_i)(v_I + w_I)}\\] \\(~\\)\n\n\n\n\n\\(~\\)\n$$\n\\[\\begin{bmatrix}dv_I/dt\\\\\ndv_O/dt\\\\\ndw_I/dt\\\\\ndw_O/dt\n\\end{bmatrix}\\]\n=\n\\[\\begin{bmatrix}-\\mu_{Iv} + m_v(a - 1)  & m_v & am_v &  0\\\\\n1/T_v & 1/T_v -\\mu_{Ov} & 0 & 0\\\\\nam_w & 0 & -\\mu_{Iw} + m_w(a - 1) & m_w\\\\\n0 & 0 & 1/Tw & 1/T_w -\\mu_{Ow}\n\\end{bmatrix}\\]\n\n\\[\\begin{bmatrix}v_I\\\\\nv_O\\\\\nw_I\\\\\nw_O\n\\end{bmatrix}\\]\n$$\n\n\n\nCode\nm1 &lt;- matrix(c(1:4), ncol = 1)\n\nm2 &lt;- matrix(c(1:16), nrow = 4, ncol = 4)\n\nm2 %*% m1\n\n\n     [,1]\n[1,]   90\n[2,]  100\n[3,]  110\n[4,]  120\n\n\nCreate a function to calculate reproductive value for each state\n\n\nCode\nchange_repro_values &lt;- \n  matrix(c(-1*death_rate_in_choosy_sex + mating_rate_choosy_sex *(a - 1),\n           mating_rate_choosy_sex,\n           a*mating_rate_choosy_sex,\n           0,\n           1/time_out_duration_choosy_sex,\n           -1/time_out_duration_choosy_sex - death_rate_out_choosy_sex,\n           0,\n           0,\n           a*mating_rate_opp_sex,\n           0,\n           -1*death_rate_in_opp_sex + mating_rate_opp_sex *(a - 1),\n           mating_rate_opp_sex,\n           0,\n           0,\n           1/time_out_duration_opp_sex,\n           -1/time_out_duration_opp_sex - death_rate_out_opp_sex),\n         nrow = 4, ncol = 4)\n\nstate_repro_values &lt;- c(vI, vO, wI, wO)\n\nparameters &lt;- \n  expand_grid(r = 0.5,\n              x = c(0, 0.5, 1),\n              death_rate_in_choosy_sex = 1,\n              mating_rate_choosy_sex = ,\n              time_out_duration_choosy_sex = c(0.1, 0.01),\n              death_rate_out_choosy_sex = 1,\n              mating_rate_opp_sex = ,\n              death_rate_in_opp_sex = 1,\n              time_out_duration_opp_sex = ,\n              death_rate_out_opp_sex = 1,\n              a = ((mating_rate_choosy_sex*(1/time_out_duration_choosy_sex + death_rate_in_choosy_sex)/\n                      (death_rate_out_choosy_sex/time_out_duration_choosy_sex + \n                         death_rate_in_choosy_sex*(mating_rate_choosy_sex + death_rate_out_choosy_sex)))^-1)/2\n  )"
  },
  {
    "objectID": "Selfish_inbreeding.html#changing-the-focus-from-chromosomes-to-alleles",
    "href": "Selfish_inbreeding.html#changing-the-focus-from-chromosomes-to-alleles",
    "title": "Selfish_inbreeding",
    "section": "",
    "text": "I think we can answer our question using the Kokko and Ots framework, but is it the right choice? Given we take a gene’s eye view, is a population genetic model (or if too difficult, a simulation) required.\nKin selection pop-gen models are well developed, by the time in, time out investment into reproduction dynamics is going to require lots of thinking on my behalf.\nThis is my first goal…\n\n\n\nLet’s build a single autosomal locus, bi-allelic model, assuming Hardy-Weinberg equilibrium.\n\nThe \\(A\\) allele is the ‘non-donor’ allele (can be thought of as an allele encoding outbreeding preference). The frequency of this allele is \\(p\\).\nThe \\(a\\) allele is the donor allele (the altruistic allele, which may encode inbreeding preference). The frequency of this allele is \\(q = 1 - p\\).\n\\(1 - h^2\\) is the likelihood that the \\(Aa\\) genotype exhibits the altruistic behaviour. If \\(h^2 = 1\\) then the allele is completely recessive.\n\nThe next step is to find all possible mating types:\n\n\nCode\nmake_mating_table &lt;- function(){#k, normalP1, P1cost, P2cost){\n  \n  make_offspring &lt;- function(X, Y, type, zygote_freq){\n    tibble(mother = X,\n           father = Y,\n           type,\n           zygote_freq)\n  }\n\n  # Set up the 9 possible mating combinations\n  \n  mating_types &lt;- expand_grid(\n    mother = c(\"AA_female\",\n               \"Aa_female\",\n               \"aa_female\"),\n    father = c(\"AA_male\",\n                \"Aa_male\",\n                \"aa_male\"))\n\n\n # Specify the possible offspring genotypes for all the potential crosses; we use these for the type argument in the make_offspring function\n  \n  # AA x AA\n  \n  g0 &lt;- c(\"AA_female\", \"AA_male\")\n  \n  # Aa x AA & AA x Aa\n  \n  g1 &lt;- c(\"AA_female\", \"AA_male\", \"Aa_female\", \"Aa_male\")\n  \n  # aa x AA & AA x aa\n  \n  g2 &lt;- c(\"Aa_female\", \"Aa_male\")\n  \n  # Aa x Aa\n  \n  g3 &lt;- c(\"AA_female\", \"AA_male\", \"Aa_female\", \"Aa_male\", \"aa_female\", \"aa_male\")\n  \n  # Aa x aa & aa x Aa\n  \n  g4 &lt;- c(\"Aa_female\", \"Aa_male\", \"aa_female\", \"aa_male\")\n  \n  # aa x aa\n  \n  g5 &lt;- c(\"aa_female\", \"aa_male\")\n  \n  # Now calculate the zygote frequencies for each cross\n  \n  # even frequency of four offspring types\n  \n  rep25 &lt;- rep(0.25, 4)\n  \n  # even frequency between two offspring types\n  \n  rep5 &lt;- rep(0.5, 2)\n  \n  # Aa * Aa\n  \n  p1 &lt;- c(0.5*0.25,\n          0.5*0.25,\n          0.5*0.5,\n          0.5*0.5,\n          0.5*0.25,\n          0.5*0.25)\n  \n    bind_rows(\n    list(\n      make_offspring(\"AA\", \"AA\", g0, rep5),\n      make_offspring(\"AA\", \"Aa\", g1, rep25),\n      make_offspring(\"AA\", \"aa\", g2, rep5),\n      make_offspring(\"Aa\", \"AA\", g1, rep25),\n      make_offspring(\"Aa\", \"Aa\", g3, p1),\n      make_offspring(\"Aa\", \"aa\", g4, rep25),\n      make_offspring(\"aa\", \"AA\", g2, rep5),\n      make_offspring(\"aa\", \"Aa\", g4, rep25),\n      make_offspring(\"aa\", \"aa\", g5, rep5)\n    )) %&gt;% \n    arrange(mother, father)\n  \n}\n\nmake_mating_table() %&gt;% \n  rename(zygote_type = type) %&gt;% \n  kable() %&gt;% \n  kable_styling() %&gt;% \n  scroll_box(height = \"500px\")\n\n\nThe frequency of each mating type can be generated using the terms of the classic equation:\n\\[(p^2 + 2pq + q^2)^2\\] Note the final square generates the mating combination.\nThe frequencies of each genotype are\n\n\nCode\n(Mating_type_freqs &lt;-\n  tibble(mother = c(\"AA\",\"AA\",\"AA\",\"Aa\",\"Aa\",\"Aa\",\"aa\",\"aa\",\"aa\"),\n         father = c(\"AA\",\"Aa\",\"aa\",\"AA\",\"Aa\",\"aa\",\"AA\",\"Aa\",\"aa\"),\n         frequency = c(\"(p^4)/2\", \"(4p^3*q)/2\", \"(2p^2*2q^2)/2\", \"(4p^3*q)/2\",\n                       \"(4p^2*q^2)/2\", \"(4p*q^3)/2\", \"(2p^2*2q^2)/2\", \"(4p*q^3)/2\",\n                       \"(q^4)/2\"\n                       )) %&gt;% \n  kable() %&gt;% \n    kable_styling())"
  },
  {
    "objectID": "Selfish_inbreeding.html#function-to-determine-the-mating-type-frequencies-of-the-population",
    "href": "Selfish_inbreeding.html#function-to-determine-the-mating-type-frequencies-of-the-population",
    "title": "Selfish_inbreeding",
    "section": "",
    "text": "This is a two-step process. First we determine the frequencies of each genotype in the mating population (this could be, for example, after we’ve accounted for inbreeding costs), then we calculate the frequencies of each potential mating combination between these genotypes.\nStep 1 - finding the genotype frequencies in the mating population\nHere we can model an inbreeding depression effect, by changing the viability of different genotypes. I make this a constant for now, to aid my initial understanding, but later this will be one of the key parameters to vary.\nI have also allowed the dominance of \\(a\\) to vary. While inbreeding depression is the result of the increased expression of recessive alleles through homozygosity, partially recessive alleles are likely to be common. When \\(h = 1\\), the \\(a\\) allele is completely recessive.\n\n\nCode\negg_adult_viability_Aa_finder &lt;- function(h){1 - 0.33*(1 - h)}\n\n\n# viability of each genotype \n\negg_adult_viability_AA_female &lt;- 1\n\negg_adult_viability_Aa_female &lt;- egg_adult_viability_Aa_finder(h = 1)\n\negg_adult_viability_aa_female &lt;- 0.67\n\negg_adult_viability_AA_male &lt;- 1\n\negg_adult_viability_Aa_male &lt;- egg_adult_viability_Aa_finder(h = 1)\n\negg_adult_viability_aa_male &lt;- 0.67\n\n\nUsing these parameters, we implement selection, so that each genotype is represented in the mating combinations according to the product of its frequency and its viability, which is determined by inbreeding depression. I assume that mating success is constant across genotypes (this may not be possible if one allele approaches extinction).\nStep 2 - finding the frequency of all potential mating combinations in the mating population\nNext, we model the effect of inbreeding preference on inclusive fitness (direct + indirect fitness). I first assume that individuals are faced with a simultaneous choice situation - between mating with a relative or mating with an unrelated individual.\nFor simplicity at the outset, I assume that inbreeding preference is only expressed in females. To simulate inbreeding preference, females carrying the \\(a\\) allele mate with siblings (those individuals produced by the same parental genotype combination). However, dominance also plays a role here. A proportion \\(1 - h\\) of \\(Aa\\) females express inbreeding preference, whereas a proportion \\(h\\) do not.\nWith the above in mind, I calculate the expected frequencies of each possible ‘mating combination’ (i.e. the combination of the maternal and paternal genotypes) across the population. For singly-mated females with genotype \\(AA\\), the frequency of each mating type is simply given by \\(F_iM_j\\), where \\(F_i\\) and \\(M_j\\) are the female and male parental genotype frequencies, that is they choose mates at random. For females with genotype \\(Aa\\) a proportion \\(1 - h\\) express a preference for inbreeding. For these females, the expected frequencies for each mating type are determined by the parental mating type combination they were produced by. These females randomly choose a mate from a subset of possible genotypes produced by the parental combination e.g. an \\(AA\\) x \\(aa\\) mating will produce a female that will choose to mate with a \\(Aa\\) male (the only possible genotype of her brothers). The proportion \\(h\\) of \\(Aa\\) females not expressing the \\(a\\) allele choose mates at random. Finally, All \\(aa\\) females choose to mate with individuals sired by the same parental genotypes.\n\n\nCode\nfind_mating_type_frequencies &lt;- function(pop, prob_remating_SD, prob_remating_W){\n  \n  # Step 1\n  \n  pop$prop &lt;- pop$prop * pop$egg_adult_viability # here's the selection step \n  pop$prop &lt;- pop$prop / sum(pop$prop) # now restandardise so that the props sum to 1\n  \n  # Step 2\n  \n  # Calculate the frequency of each single-mating combination\n  \n  first_mating_types &lt;- \n    expand_grid(mother = pop$type[str_detect(pop$type, \"female\")], # find all possible mother genotypes\n                father = pop$type[!str_detect(pop$type, \"female\")]) %&gt;% # find all possible father1 genotypes\n    mutate(prop_matings = 0, remating_probability = 0) # make placeholder columns we will fill in below\n  \n  # find genotype frequencies calculated for each sex (mate choice means these will not necessarily be 50:50)\n  \n  female_frequencies &lt;- pop %&gt;% filter(str_detect(type, \"female\")) %&gt;% mutate(prop = prop / sum(prop))\n  male_frequencies &lt;- pop %&gt;% filter(!str_detect(type, \"female\")) %&gt;% mutate(prop = prop / sum(prop))\n  \n  # This next step multiplies the proportion[i] of females with genotype[i] with the proportion[i] of males with genotype[i] \n  \n  for(i in 1:nrow(first_mating_types)){\n    first_mating_types$prop_matings[i] &lt;- female_frequencies$prop[female_frequencies$type == first_mating_types$mother[i]] * \n      male_frequencies$prop[male_frequencies$type == first_mating_types$father1[i]]\n  }\n  \n  # Now we incorporate female remating probabilities (SDSD males assumed to have same effect on females as WW males)\n  \n  first_mating_types$remating_probability &lt;- ifelse(str_detect(first_mating_types$father1, \"WSD\"), prob_remating_SD, prob_remating_W)\n  \n  # Now lets calculate the frequency of each double-mating combination, with the end product being the mating_type_frequency of each mating possibility\n  \n  second_mating_types &lt;- expand_grid(first_mating_types, father2 = c(\"none\", unique(first_mating_types$father1))) %&gt;%\n    mutate(mating_type_freq = 0)\n  \n  # scale the proportion of matings calculated above by the likelihood that these females will mate once\n  \n  for(i in 1:nrow(second_mating_types)){\n    if(second_mating_types$father2[i] == \"none\"){\n      second_mating_types$mating_type_freq[i] &lt;- \n        second_mating_types$prop_matings[i] * # Frequency of females with this value of father1\n        (1 - second_mating_types$remating_probability[i])\n    }\n    \n    # now calculate the frequency of mating tryads for the females that mate twice\n    \n    if(second_mating_types$father2[i] != \"none\"){\n      second_mating_types$mating_type_freq[i] &lt;- \n        second_mating_types$prop_matings[i] * # Frequency of females with this value of father1\n        second_mating_types$remating_probability[i] *\n        male_frequencies$prop[male_frequencies$type == second_mating_types$father2[i]] # pop. freq of the 2nd male type\n    }\n  }\n  \n  second_mating_types %&gt;% # output\n    select(mother, father1, father2, mating_type_freq) %&gt;%\n    # clean up the output by remving redundant info (makes it easier later)\n    mutate(mother = str_remove_all(mother, \"_female\"),\n           father1 = str_remove_all(father1, \"_male\"),\n           father2 = str_remove_all(father2, \"_male\"))\n}"
  },
  {
    "objectID": "Selfish_inbreeding.html#time-in-and-time-out",
    "href": "Selfish_inbreeding.html#time-in-and-time-out",
    "title": "Selfish_inbreeding",
    "section": "",
    "text": "\\(~\\)\nThis is hard, but everything should be in the Kokko and Ots paper\nWe can now directly follow Kokko and Ots (2006), altering the equations where required to reflect the fitness consequences of inbreeding for different chromosomes.\n\n\n\n\n\n\nParameter definitions\n\n\n\n\\(\\delta\\): fraction of offspring lost due to inbreeding (inbreeding depression)\n\\(v_I\\): ‘time in’ reproductive value of individuals of the choosing sex\n\\(w_I\\): ‘time in’ reproductive value of individuals of the opposite sex\n\\(v_O\\): ‘time out’ reproductive value of individuals of the choosing sex\n\\(w_O\\): ‘time out’ reproductive value of individuals of the opposite sex\n\\(M\\): the unrelated mate encounter rate during time in (when sex ratio is unbiased)\n\\(m_v = M \\sqrt{\\beta}\\): the mating rate for the choosy sex\n\\(m_w = \\frac{M}{\\sqrt{\\beta}}\\): the mating rate for the opposite sex\n\\(\\beta\\): the operational sex ratio (males:females)\n\\(a\\): average number of offspring produced from a mating (I think - needs to be found numerically)\n\\(T_v\\): time out duration for choosing sex\n\\(T_w\\): time out duration for opposite sex\n\\(\\mu_{Iv}\\): ‘time in’ mortality risk of individuals of the choosing sex\n\\(\\mu_{Iw}\\): ‘time in’ mortality risk of individuals of the opposite sex\n\\(\\mu_{Ov}\\): ‘time out’ mortality risk of individuals of the choosing sex\n\\(\\mu_{Ow}\\): ‘time out’ mortality risk of individuals of the opposite sex\n\n\nAfter mating, offspring are produced, with a direct fitness benefit of \\[a(v_I + w_I)\\]\n\n\nThe choosing sex can either mate with an unrelated individual or an individual related by \\(r\\).\nMate with unrelated individual: \\(v_O + ro_iw_I + a(v_I + w_1)\\)\nMate with kin: \\(v_O + ro_iw_O + (1 + ro_i)(1 - \\delta)a(v_I + w_1)\\)\nWe continue to frame our study around the value of \\(\\delta\\) that can be tolerated, or put another way, to what extent can inbreeding reduce offspring viability and still be the selected strategy?\nWe therefore rearrange the equation to find the threshold value of \\(\\delta\\) where\n\\[v_O + ro_iw_O + (1 + ro_i)(1 - \\delta)a(v_I + w_1) \\gt v_O + ro_iw_I + a(v_I + w_1)\\]\nto\n\\[\\delta_{sim} = 1 - \\frac{a(v_I + w_I) + ro_i(w_I - w_O)}{a(1 + ro_i)(v_I + w_I)}\\] which can be more neatly expressed as\n\\[\\delta_{sim} = \\frac{a ro_i(v_I + w_I) - ro_i(w_I - w_O)}{a(1 + ro_i)(v_I + w_I)}\\]\n\n\n\nIn this scenario, a choosy individual (note that our models are framed around the strategy adopted by the choosy individuals) encounters a single potential mate, related by \\(r\\). The choosing sex can either mate with this individual or elect not to mate and wait for a future opportunity.\nNot mating produces the inclusive fitness:\n\\[v_I + ro_iw_I\\] Now an inbreeding preference strategy is favoured where\n\\[v_O + ro_iw_O + (1 + ro_i)(1 - \\delta)a(v_I + w_1) \\gt v_I + ro_iw_I\\]\nThus, the threshold \\(\\delta\\) value below which inbreeding is adaptive is\n\\[\\delta_{seq} = 1 - \\frac{(v_I - v_O) + ro_i(w_I - w_O)}{a(1 + ro_i)(v_I + w_I)}\\] \\(~\\)\n\n\n\n\n\\(~\\)\n$$\n\\[\\begin{bmatrix}dv_I/dt\\\\\ndv_O/dt\\\\\ndw_I/dt\\\\\ndw_O/dt\n\\end{bmatrix}\\]\n=\n\\[\\begin{bmatrix}-\\mu_{Iv} + m_v(a - 1)  & m_v & am_v &  0\\\\\n1/T_v & 1/T_v -\\mu_{Ov} & 0 & 0\\\\\nam_w & 0 & -\\mu_{Iw} + m_w(a - 1) & m_w\\\\\n0 & 0 & 1/Tw & 1/T_w -\\mu_{Ow}\n\\end{bmatrix}\\]\n\n\\[\\begin{bmatrix}v_I\\\\\nv_O\\\\\nw_I\\\\\nw_O\n\\end{bmatrix}\\]\n$$\n\n\n\nCode\nm1 &lt;- matrix(c(1:4), ncol = 1)\n\nm2 &lt;- matrix(c(1:16), nrow = 4, ncol = 4)\n\nm2 %*% m1\n\n\n     [,1]\n[1,]   90\n[2,]  100\n[3,]  110\n[4,]  120\n\n\nCreate a function to calculate reproductive value for each state\n\n\nCode\nchange_repro_values &lt;- \n  matrix(c(-1*death_rate_in_choosy_sex + mating_rate_choosy_sex *(a - 1),\n           mating_rate_choosy_sex,\n           a*mating_rate_choosy_sex,\n           0,\n           1/time_out_duration_choosy_sex,\n           -1/time_out_duration_choosy_sex - death_rate_out_choosy_sex,\n           0,\n           0,\n           a*mating_rate_opp_sex,\n           0,\n           -1*death_rate_in_opp_sex + mating_rate_opp_sex *(a - 1),\n           mating_rate_opp_sex,\n           0,\n           0,\n           1/time_out_duration_opp_sex,\n           -1/time_out_duration_opp_sex - death_rate_out_opp_sex),\n         nrow = 4, ncol = 4)\n\nstate_repro_values &lt;- c(vI, vO, wI, wO)\n\nparameters &lt;- \n  expand_grid(r = 0.5,\n              x = c(0, 0.5, 1),\n              death_rate_in_choosy_sex = 1,\n              mating_rate_choosy_sex = ,\n              time_out_duration_choosy_sex = c(0.1, 0.01),\n              death_rate_out_choosy_sex = 1,\n              mating_rate_opp_sex = ,\n              death_rate_in_opp_sex = 1,\n              time_out_duration_opp_sex = ,\n              death_rate_out_opp_sex = 1,\n              a = ((mating_rate_choosy_sex*(1/time_out_duration_choosy_sex + death_rate_in_choosy_sex)/\n                      (death_rate_out_choosy_sex/time_out_duration_choosy_sex + \n                         death_rate_in_choosy_sex*(mating_rate_choosy_sex + death_rate_out_choosy_sex)))^-1)/2\n  )"
  }
]